Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/TestTeleOpMode2.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/* Copyright (c) 2017 FIRST. All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without modification,\r\n * are permitted (subject to the limitations in the disclaimer below) provided that\r\n * the following conditions are met:\r\n *\r\n * Redistributions of source code must retain the above copyright notice, this list\r\n * of conditions and the following disclaimer.\r\n *\r\n * Redistributions in binary form must reproduce the above copyright notice, this\r\n * list of conditions and the following disclaimer in the documentation and/or\r\n * other materials provided with the distribution.\r\n *\r\n * Neither the name of FIRST nor the names of its contributors may be used to endorse or\r\n * promote products derived from this software without specific prior written permission.\r\n *\r\n * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS\r\n * LICENSE. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\r\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\r\n * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\r\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE\r\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\r\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\r\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\r\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\r\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\r\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n */\r\n\r\npackage org.firstinspires.ftc.teamcode;\r\n\r\n\r\nimport static java.lang.Math.round;\r\n\r\nimport com.qualcomm.robotcore.eventloop.opmode.Disabled;\r\nimport com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;\r\nimport com.qualcomm.robotcore.eventloop.opmode.TeleOp;\r\nimport com.qualcomm.robotcore.hardware.DcMotor;\r\nimport com.qualcomm.robotcore.hardware.DcMotorSimple;\r\nimport com.qualcomm.robotcore.hardware.Servo;\r\nimport com.qualcomm.robotcore.util.ElapsedTime;\r\nimport com.qualcomm.robotcore.util.Range;\r\n\r\n\r\n/**\r\n * This file contains an minimal example of a Linear \"OpMode\". An OpMode is a 'program' that runs in either\r\n * the autonomous or the teleop period of an FTC match. The names of OpModes appear on the menu\r\n * of the FTC Driver Station. When an selection is made from the menu, the corresponding OpMode\r\n * class is instantiated on the Robot Controller and executed.\r\n *\r\n * This particular OpMode just executes a basic Tank Drive Teleop for a two wheeled robot\r\n * It includes all the skeletal structure that all linear OpModes contain.\r\n *\r\n * Use Android Studios to Copy this Class, and Paste it into your team's code folder with a new name.\r\n * Remove or comment out the @Disabled line to add this opmode to the Driver Station OpMode list\r\n */\r\n\r\n@TeleOp(name=\"Real TeleOp Drive\", group=\"Linear Opmode\")\r\n//@Disabled\r\npublic class TestTeleOpMode2 extends LinearOpMode {\r\n\r\n    // Declare OpMode members.\r\n    private ElapsedTime runtime = new ElapsedTime();\r\n    DcMotor carousel;\r\n    DcMotor extender;\r\n    Servo grabber;\r\n\r\n\r\n    static final double INCREMENT   = 0.01;     // amount to slew servo each CYCLE_MS cycle\r\n    static final int    CYCLE_MS    =   50;     // period of each cycle\r\n    static final double MAX_POS     =  1.0;     // Maximum rotational position\r\n    static final double MIN_POS     =  0.0;     // Minimum rotational position\r\n    double servoPosition = 0.3;\r\n\r\n    Thread armThread;\r\n    Thread carouselThread;\r\n\r\n    boolean isExtended = false;\r\n    boolean isGrabbing = true;\r\n    boolean servoMoving = false;\r\n    @Override\r\n    public void runOpMode() {\r\n        DriveTrain drive = new DriveTrain(hardwareMap);\r\n        telemetry.addData(\"Status\", \"Initialized\");\r\n        telemetry.update();\r\n\r\n        carousel = hardwareMap.get(DcMotor.class, \"Carousel\");\r\n        carousel.setDirection(DcMotor.Direction.REVERSE);\r\n\r\n        extender = hardwareMap.get(DcMotor.class, \"ExtensionArm\");\r\n        extender.setDirection(DcMotor.Direction.FORWARD);\r\n        extender.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n        extender.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\r\n\r\n\r\n\r\n        grabber = hardwareMap.get(Servo.class, \"Grabber\");\r\n\r\n        grabber.setPosition(servoPosition);\r\n\r\n        carouselThread = new Thread(){\r\n            @Override\r\n            public void run(){\r\n                while(opModeIsActive()){\r\n                    carouselUpdate();\r\n                }\r\n            }\r\n        };\r\n\r\n        armThread = new Thread(){\r\n            @Override\r\n            public void run(){\r\n                while(opModeIsActive()){\r\n                    armUpdate();\r\n                }\r\n            }\r\n        };\r\n        //Wait for the game to start (driver presses PLAY)\r\n        waitForStart();\r\n        runtime.reset();\r\n        armThread.start();\r\n        carouselThread.start();\r\n        //extendArm(200);\r\n        grabber.setPosition(servoPosition);\r\n        //extendArm(300);\r\n\r\n        // run until the end of the match (driver presses STOP)\r\n        while (opModeIsActive()) {\r\n\r\n            if (gamepad1.right_bumper) {\r\n                drive.setPower(gamepad1.left_stick_y, gamepad1.right_stick_x * .6);\r\n            } else {\r\n                drive.setPower(gamepad1.left_stick_y / 2, gamepad1.right_stick_x / 2);\r\n            }\r\n\r\n\r\n\r\n            // Show the elapsed game time and wheel power.\r\n            telemetry.addData(\"Status\", \"Run Time: \" + runtime.toString());\r\n            telemetry.addData(\"Extender Tics\", \"Tics: \" + extender.getCurrentPosition());\r\n            telemetry.addData(\"Servo Position\", servoPosition);\r\n            telemetry.addData(\"Servo Position Actual\", grabber.getPosition());\r\n            //telemetry.addData(\"Motors\", \"left (%.2f), right (%.2f)\", leftPower, rightPower);\r\n            telemetry.update();\r\n        }\r\n    }\r\n\r\n    private void carouselUpdate() {\r\n\r\n        if(gamepad1.dpad_right) {\r\n            carousel.setPower(0.7);\r\n        } else if(gamepad1.dpad_left) {\r\n            carousel.setPower(0.7);\r\n        } else {\r\n            carousel.setPower(0);\r\n        }\r\n\r\n        if (gamepad1.a) {\r\n            spinCarousel(4000);\r\n        }\r\n\r\n    }\r\n\r\n    private void armUpdate() {\r\n        if (gamepad1.left_trigger > 0.1 && isExtended) {\r\n            isExtended = false;\r\n            extendArm(300);\r\n        } else if (gamepad1.right_trigger > 0.1 && !isExtended) {\r\n            isExtended = true;\r\n            extendArm(8900);\r\n        }\r\n\r\n        if(gamepad1.dpad_up) {\r\n            extender.setPower(0.5);\r\n        } else if(gamepad1.dpad_down) {\r\n            extender.setPower(-0.3);\r\n        } else {\r\n            extender.setPower(0);\r\n        }\r\n\r\n\r\n\r\n        // ~6.28 inches per rotation, need to extend 28 inches, Don't Overshoot!!!,\r\n        // 4.45 rotations, ~2220.4 tics/rotation\r\n        if (gamepad1.b && !isExtended) {\r\n            isExtended = true;\r\n            extendArm(8900);\r\n        }\r\n\r\n        if (gamepad1.x && isExtended) {\r\n            isExtended = false;\r\n            extendArm(300);\r\n        }\r\n\r\n        if (gamepad1.left_bumper) {\r\n            extender.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n            extender.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\r\n        }\r\n\r\n        if (gamepad1.y) {\r\n            grab(0.3);\r\n        }\r\n\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n    boolean previousYState;\r\n    public synchronized void grab(double position){\r\n        double targetPosition;\r\n        servoMoving = true;\r\n\r\n        previousYState = gamepad1.y;\r\n\r\n        if(isGrabbing) {\r\n            targetPosition = 0;\r\n        }else{\r\n            targetPosition = position;\r\n        }\r\n\r\n        servoPosition = targetPosition;\r\n        grabber.setPosition(servoPosition);\r\n\r\n        while(previousYState == gamepad1.y){\r\n\r\n        }\r\n        isGrabbing = !isGrabbing;\r\n\r\n    }\r\n\r\n    public void spinCarousel(int tics) {\r\n\r\n\r\n\r\n        carousel.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n\r\n        carousel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n\r\n        carousel.setTargetPosition(tics);\r\n\r\n        double power;\r\n\r\n        carousel.setPower(0.5);\r\n\r\n        while (carousel.isBusy()) {\r\n            power = 2 * (1- (Math.abs(carousel.getCurrentPosition() - carousel.getTargetPosition()) / 4000.0));\r\n            if (power < 0.5) {\r\n                carousel.setPower(0.5);\r\n            } else if (power > 1){\r\n                carousel.setPower(1);\r\n            } else {\r\n                carousel.setPower(power);\r\n            }\r\n        }\r\n\r\n        carousel.setPower(0);\r\n\r\n        carousel.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\r\n\r\n    }\r\n\r\n    public void extendArm(int armPosition) {\r\n\r\n        extender.setTargetPosition(armPosition);\r\n\r\n        extender.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n\r\n        extender.setPower(0.5);\r\n\r\n        while (extender.isBusy()) {\r\n\r\n        }\r\n\r\n        extender.setPower(0);\r\n\r\n        extender.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\r\n    }\r\n\r\n}\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/TestTeleOpMode2.java b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/TestTeleOpMode2.java
--- a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/TestTeleOpMode2.java	
+++ b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/TestTeleOpMode2.java	
@@ -70,13 +70,13 @@
     static final int    CYCLE_MS    =   50;     // period of each cycle
     static final double MAX_POS     =  1.0;     // Maximum rotational position
     static final double MIN_POS     =  0.0;     // Minimum rotational position
-    double servoPosition = 0.3;
+    double servoPosition = 0;
 
     Thread armThread;
     Thread carouselThread;
 
     boolean isExtended = false;
-    boolean isGrabbing = true;
+    boolean isGrabbing = false;
     boolean servoMoving = false;
     @Override
     public void runOpMode() {
@@ -158,6 +158,9 @@
         if (gamepad1.a) {
             spinCarousel(4000);
         }
+        if (gamepad1.b) {
+            spinCarousel(-4000);
+        }
 
     }
 
@@ -182,6 +185,7 @@
 
         // ~6.28 inches per rotation, need to extend 28 inches, Don't Overshoot!!!,
         // 4.45 rotations, ~2220.4 tics/rotation
+        /*
         if (gamepad1.b && !isExtended) {
             isExtended = true;
             extendArm(8900);
@@ -192,6 +196,8 @@
             extendArm(300);
         }
 
+         */
+
         if (gamepad1.left_bumper) {
             extender.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
             extender.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);
@@ -267,7 +273,12 @@
 
         extender.setMode(DcMotor.RunMode.RUN_TO_POSITION);
 
-        extender.setPower(0.5);
+        if(!isExtended) {
+            extender.setPower(0.5);
+        } else {
+            extender.setPower(1);
+        }
+
 
         while (extender.isBusy()) {
 
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/CarouselAutoBlue.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.teamcode;\r\n\r\nimport com.qualcomm.robotcore.eventloop.opmode.Autonomous;\r\nimport com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;\r\nimport com.qualcomm.robotcore.hardware.DcMotor;\r\n\r\nimport static org.firstinspires.ftc.robotcore.external.BlocksOpModeCompanion.hardwareMap;\r\nimport static org.firstinspires.ftc.robotcore.external.BlocksOpModeCompanion.linearOpMode;\r\n\r\n@Autonomous(name = \"Carousel Auto (blue)\", group = \"Linear Opmode\")\r\n\r\npublic class CarouselAutoBlue extends LinearOpMode {\r\n    DcMotor carousel;\r\n\r\n\r\n    @Override\r\n    public void runOpMode(){\r\n        DriveTrain drive = new DriveTrain(hardwareMap);\r\n\r\n        carousel = hardwareMap.get(DcMotor.class, \"Carousel\");\r\n        carousel.setDirection(DcMotor.Direction.REVERSE);\r\n\r\n\r\n\r\n        waitForStart();\r\n\r\n\r\n        //First turn to carousel\r\n        drive.rf.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n        drive.rf.setTargetPosition(200);\r\n        drive.rf.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n\r\n        drive.rf.setPower(0.5);\r\n\r\n        while(drive.rf.isBusy()){\r\n\r\n        }\r\n\r\n        drive.brake();\r\n\r\n        sleep(1000);\r\n\r\n\r\n        //Carousel spin\r\n        spinCarousel(4000);\r\n\r\n\r\n        /*sleep(1000);\r\n\r\n        drive.lf.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n        drive.lf.setTargetPosition(200);\r\n        drive.lf.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n\r\n        drive.lf.setPower(0.5);\r\n\r\n        while(Math.abs(drive.lf.getCurrentPosition() - drive.lf.getTargetPosition()) > 20){\r\n\r\n        }\r\n\r\n        drive.brake();\r\n        */\r\n\r\n        sleep(1000);\r\n\r\n        //drive.goToPosition(300, false);\r\n\r\n        //sleep(1000);\r\n\r\n        //Backing up away from carousel\r\n        //double startTime = linearOpMode.time;\r\n        drive.rf.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n        drive.rf.setTargetPosition(-200);\r\n        drive.rf.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n\r\n        drive.rf.setPower(0.5);\r\n\r\n        while(drive.rf.isBusy()){\r\n\r\n        }\r\n\r\n        drive.brake();\r\n\r\n        sleep(1000);\r\n\r\n        //Turning towards parking\r\n        drive.lf.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n        drive.lf.setTargetPosition(250);\r\n        drive.lf.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n\r\n        drive.lf.setPower(0.5);\r\n\r\n\r\n\r\n        while(drive.lf.isBusy()){\r\n\r\n        }\r\n\r\n        drive.brake();\r\n\r\n        sleep(1000);\r\n\r\n\r\n        //Driving into park\r\n        drive.goToPosition(630, false);\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n    public void spinCarousel(int tics) {\r\n\r\n\r\n\r\n        carousel.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n        carousel.setTargetPosition(tics);\r\n\r\n\r\n        carousel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n\r\n\r\n        double power;\r\n\r\n        carousel.setPower(0.2);\r\n\r\n        while(carousel.isBusy()){\r\n\r\n        }\r\n\r\n        /*while (carousel.isBusy()) {\r\n            power = 2 * (1- (Math.abs(carousel.getCurrentPosition() - carousel.getTargetPosition()) / 4000.0));\r\n            if (power < 0.5) {\r\n                carousel.setPower(0.5);\r\n            } else if (power > 1){\r\n                carousel.setPower(1);\r\n            } else {\r\n                carousel.setPower(power);\r\n            }\r\n        }\r\n\r\n         */\r\n\r\n        carousel.setPower(0);\r\n\r\n        carousel.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\r\n\r\n    }\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/CarouselAutoBlue.java b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/CarouselAutoBlue.java
--- a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/CarouselAutoBlue.java	
+++ b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/CarouselAutoBlue.java	
@@ -3,6 +3,7 @@
 import com.qualcomm.robotcore.eventloop.opmode.Autonomous;
 import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;
 import com.qualcomm.robotcore.hardware.DcMotor;
+import com.qualcomm.robotcore.hardware.Servo;
 
 import static org.firstinspires.ftc.robotcore.external.BlocksOpModeCompanion.hardwareMap;
 import static org.firstinspires.ftc.robotcore.external.BlocksOpModeCompanion.linearOpMode;
@@ -11,6 +12,8 @@
 
 public class CarouselAutoBlue extends LinearOpMode {
     DcMotor carousel;
+    Servo grabber;
+
 
 
     @Override
@@ -20,6 +23,10 @@
         carousel = hardwareMap.get(DcMotor.class, "Carousel");
         carousel.setDirection(DcMotor.Direction.REVERSE);
 
+        grabber = hardwareMap.get(Servo.class, "Grabber");
+
+        grabber.setPosition(0);
+
 
 
         waitForStart();
