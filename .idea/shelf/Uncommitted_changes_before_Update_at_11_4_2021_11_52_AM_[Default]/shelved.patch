Index: TeamCode/build.gradle
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//\r\n// build.gradle in TeamCode\r\n//\r\n// Most of the definitions for building your module reside in a common, shared\r\n// file 'build.common.gradle'. Being factored in this way makes it easier to\r\n// integrate updates to the FTC into your code. If you really need to customize\r\n// the build definitions, you can place those customizations in this file, but\r\n// please think carefully as to whether such customizations are really necessary\r\n// before doing so.\r\n\r\n\r\n// Custom definitions may go here\r\n\r\n// Include common definitions from above.\r\napply from: '../build.common.gradle'\r\napply from: '../build.dependencies.gradle'\r\n\r\ndependencies {\r\n    implementation project(':FtcRobotController')\r\n    annotationProcessor files('lib/OpModeAnnotationProcessor.jar')\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/TeamCode/build.gradle b/TeamCode/build.gradle
--- a/TeamCode/build.gradle	(revision fe13069eea588461341e0f8478d1259e7e7e54a9)
+++ b/TeamCode/build.gradle	(date 1635975862955)
@@ -18,4 +18,5 @@
 dependencies {
     implementation project(':FtcRobotController')
     annotationProcessor files('lib/OpModeAnnotationProcessor.jar')
-}
+    implementation 'org.openftc:easyopencv:1.5.0'
+}
\ No newline at end of file
Index: build.common.gradle
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/**\r\n * build.common.gradle\r\n *\r\n * Try to avoid editing this file, as it may be updated from time to time as the FTC SDK\r\n * evolves. Rather, if it is necessary to customize the build process, do those edits in\r\n * the build.gradle file in TeamCode.\r\n *\r\n * This file contains the necessary content of the 'build.gradle' files for robot controller\r\n * applications built using the FTC SDK. Each individual 'build.gradle' in those applications\r\n * can simply contain the one line:\r\n *\r\n *      apply from: '../build.common.gradle'\r\n *\r\n * which will pick up this file here. This approach allows makes it easier to integrate\r\n * updates to the FTC SDK into your code.\r\n */\r\n\r\nimport java.util.regex.Pattern\r\n\r\napply plugin: 'com.android.application'\r\n\r\nandroid {\r\n\r\n    compileSdkVersion 29\r\n\r\n    signingConfigs {\r\n        release {\r\n            def apkStoreFile = System.getenv(\"APK_SIGNING_STORE_FILE\")\r\n            if (apkStoreFile != null) {\r\n                keyAlias System.getenv(\"APK_SIGNING_KEY_ALIAS\")\r\n                keyPassword System.getenv(\"APK_SIGNING_KEY_PASSWORD\")\r\n                storeFile file(System.getenv(\"APK_SIGNING_STORE_FILE\"))\r\n                storePassword System.getenv(\"APK_SIGNING_STORE_PASSWORD\")\r\n            } else {\r\n                keyAlias 'androiddebugkey'\r\n                keyPassword 'android'\r\n                storeFile rootProject.file('libs/ftc.debug.keystore')\r\n                storePassword 'android'\r\n            }\r\n        }\r\n\r\n        debug {\r\n            keyAlias 'androiddebugkey'\r\n            keyPassword 'android'\r\n            storeFile rootProject.file('libs/ftc.debug.keystore')\r\n            storePassword 'android'\r\n        }\r\n    }\r\n\r\n    aaptOptions {\r\n        noCompress \"tflite\"\r\n    }\r\n\r\n    defaultConfig {\r\n        signingConfig signingConfigs.debug\r\n        applicationId 'com.qualcomm.ftcrobotcontroller'\r\n        minSdkVersion 23\r\n        //noinspection ExpiredTargetSdkVersion\r\n        targetSdkVersion 28\r\n\r\n        /**\r\n         * We keep the versionCode and versionName of robot controller applications in sync with\r\n         * the master information published in the AndroidManifest.xml file of the FtcRobotController\r\n         * module. This helps avoid confusion that might arise from having multiple versions of\r\n         * a robot controller app simultaneously installed on a robot controller device.\r\n         *\r\n         * We accomplish this with the help of a funky little Groovy script that maintains that\r\n         * correspondence automatically.\r\n         *\r\n         * @see <a href=\"http://developer.android.com/tools/building/configuring-gradle.html\">Configure Your Build</a>\r\n         * @see <a href=\"http://developer.android.com/tools/publishing/versioning.html\">Versioning Your App</a>\r\n         */\r\n        def manifestFile = project(':FtcRobotController').file('src/main/AndroidManifest.xml');\r\n        def manifestText = manifestFile.getText()\r\n        //\r\n        def vCodePattern = Pattern.compile(\"versionCode=\\\"(\\\\d+(\\\\.\\\\d+)*)\\\"\")\r\n        def matcher = vCodePattern.matcher(manifestText)\r\n        matcher.find()\r\n        def vCode = Integer.parseInt(matcher.group(1))\r\n        //\r\n        def vNamePattern = Pattern.compile(\"versionName=\\\"(.*)\\\"\")\r\n        matcher = vNamePattern.matcher(manifestText);\r\n        matcher.find()\r\n        def vName = matcher.group(1)\r\n        //\r\n        versionCode vCode\r\n        versionName vName\r\n    }\r\n\r\n    // Advanced user code might just want to use Vuforia directly, so we set up the libs as needed\r\n    // http://google.github.io/android-gradle-dsl/current/com.android.build.gradle.internal.dsl.BuildType.html\r\n    buildTypes {\r\n        release {\r\n            signingConfig signingConfigs.release\r\n\r\n            ndk {\r\n                abiFilters \"armeabi-v7a\", \"arm64-v8a\"\r\n            }\r\n        }\r\n        debug {\r\n            debuggable true\r\n            jniDebuggable true\r\n            renderscriptDebuggable true\r\n            ndk {\r\n                abiFilters \"armeabi-v7a\", \"arm64-v8a\"\r\n            }\r\n        }\r\n    }\r\n\r\n    compileOptions {\r\n        sourceCompatibility JavaVersion.VERSION_1_8\r\n        targetCompatibility JavaVersion.VERSION_1_8\r\n    }\r\n\r\n    packagingOptions {\r\n        pickFirst '**/*.so'\r\n    }\r\n    sourceSets.main {\r\n        jni.srcDirs = []\r\n        jniLibs.srcDir rootProject.file('libs')\r\n    }\r\n    ndkVersion '21.3.6528147'\r\n}\r\n\r\nrepositories {\r\n    flatDir {\r\n        dirs rootProject.file('libs')\r\n    }\r\n}\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/build.common.gradle b/build.common.gradle
--- a/build.common.gradle	(revision fe13069eea588461341e0f8478d1259e7e7e54a9)
+++ b/build.common.gradle	(date 1635975975243)
@@ -94,7 +94,7 @@
             signingConfig signingConfigs.release
 
             ndk {
-                abiFilters "armeabi-v7a", "arm64-v8a"
+                abiFilters "armeabi-v7a" //, "arm64-v8a"
             }
         }
         debug {
@@ -102,7 +102,7 @@
             jniDebuggable true
             renderscriptDebuggable true
             ndk {
-                abiFilters "armeabi-v7a", "arm64-v8a"
+                abiFilters "armeabi-v7a" //, "arm64-v8a"
             }
         }
     }
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/BarcodePipeline.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/BarcodePipeline.java b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/BarcodePipeline.java
new file mode 100644
--- /dev/null	(date 1635979305922)
+++ b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/BarcodePipeline.java	(date 1635979305922)
@@ -0,0 +1,163 @@
+package org.firstinspires.ftc.teamcode;
+
+import org.opencv.core.Core;
+import org.opencv.core.Mat;
+import org.opencv.core.Rect;
+import org.opencv.core.Point;
+import org.opencv.core.Scalar;
+import org.opencv.imgproc.Imgproc;
+import org.openftc.easyopencv.OpenCvPipeline;
+
+public class BarcodePipeline extends OpenCvPipeline{
+    // define position enums
+    public enum BarcodePosition
+    {
+        LEFT,
+        CENTER,
+        RIGHT
+    }
+
+    // define col constants
+    static final Scalar BLUE = new Scalar(0, 0, 255);
+    static final Scalar GREEN = new Scalar(0, 255, 0);
+
+    // get anchor points for each region
+    static final Point REGION1_TOPLEFT_ANCHOR_POINT = new Point(0, 110);
+    static final Point REGION2_TOPLEFT_ANCHOR_POINT = new Point(150, 110);
+    static final Point REGION3_TOPLEFT_ANCHOR_POINT = new Point(280, 110);
+    static final int REGION_WIDTH = 40;
+    static final int REGION_HEIGHT = 80;
+
+    // define top left and bottom right region points
+    Point region1_pointA = new Point(
+            REGION1_TOPLEFT_ANCHOR_POINT.x,
+            REGION1_TOPLEFT_ANCHOR_POINT.y);
+    Point region1_pointB = new Point(
+            REGION1_TOPLEFT_ANCHOR_POINT.x + REGION_WIDTH,
+            REGION1_TOPLEFT_ANCHOR_POINT.y + REGION_HEIGHT);
+    Point region2_pointA = new Point(
+            REGION2_TOPLEFT_ANCHOR_POINT.x,
+            REGION2_TOPLEFT_ANCHOR_POINT.y);
+    Point region2_pointB = new Point(
+            REGION2_TOPLEFT_ANCHOR_POINT.x + REGION_WIDTH,
+            REGION2_TOPLEFT_ANCHOR_POINT.y + REGION_HEIGHT);
+    Point region3_pointA = new Point(
+            REGION3_TOPLEFT_ANCHOR_POINT.x,
+            REGION3_TOPLEFT_ANCHOR_POINT.y);
+    Point region3_pointB = new Point(
+            REGION3_TOPLEFT_ANCHOR_POINT.x + REGION_WIDTH,
+            REGION3_TOPLEFT_ANCHOR_POINT.y + REGION_HEIGHT);
+
+    // Create vars
+    Mat region1_Cb, region2_Cb, region3_Cb;
+    //    Mat YCrCb = new Mat();
+//    Mat Cb = new Mat();
+    Mat RGB = new Mat();
+    Mat B = new Mat();
+    int avg1, avg2, avg3;
+
+    // create pos var, with vol tag due to the var changing at runtime
+    volatile BarcodePosition position = BarcodePosition.CENTER;
+
+
+
+    // converts rgb frame to ycrcb, extracts cb channel
+//    void inputToCb(Mat input) {
+//        Imgproc.cvtColor(input, YCrCb, Imgproc.COLOR_RGB2YCrCb);
+//        Core.extractChannel(YCrCb, Cb, 2);
+//    }
+
+    void inputToB(Mat input) {
+        Imgproc.cvtColor(input, RGB, Imgproc.COLOR_RGB2BGR);
+        Core.extractChannel(RGB, B, 0);
+    }
+
+    @Override
+    public void init(Mat frame) {
+        inputToB(frame);
+
+        region1_Cb = B.submat(new Rect(region1_pointA, region1_pointB));
+        region2_Cb = B.submat(new Rect(region2_pointA, region2_pointB));
+        region3_Cb = B.submat(new Rect(region3_pointA, region3_pointB));
+    }
+
+    @Override
+    public Mat processFrame(Mat input) {
+        inputToB(input);
+
+        region1_Cb = B.submat(new Rect(region1_pointA, region1_pointB));
+        region2_Cb = B.submat(new Rect(region2_pointA, region2_pointB));
+        region3_Cb = B.submat(new Rect(region3_pointA, region3_pointB));
+
+        avg1 = (int) Core.mean(region1_Cb).val[0];
+        avg2 = (int) Core.mean(region2_Cb).val[0];
+        avg3 = (int) Core.mean(region3_Cb).val[0];
+
+        Imgproc.rectangle(
+                input,
+                region1_pointA,
+                region1_pointB,
+                BLUE,
+                2
+        );
+
+        Imgproc.rectangle(
+                input,
+                region2_pointA,
+                region2_pointB,
+                BLUE,
+                2
+        );
+
+        Imgproc.rectangle(
+                input,
+                region3_pointA,
+                region3_pointB,
+                BLUE,
+                2
+        );
+
+        int min = Math.min(Math.min(avg1, avg2), avg3);
+
+        if (min == avg1) {
+
+            Imgproc.rectangle(
+                    input,
+                    region1_pointA,
+                    region1_pointB,
+                    GREEN,
+                    2
+            );
+
+            position = BarcodePosition.LEFT;
+        } else if (min == avg2) {
+
+            Imgproc.rectangle(
+                    input,
+                    region2_pointA,
+                    region2_pointB,
+                    GREEN,
+                    2
+            );
+
+            position = BarcodePosition.CENTER;
+        } else if (min == avg3) {
+
+            Imgproc.rectangle(
+                    input,
+                    region3_pointA,
+                    region3_pointB,
+                    GREEN,
+                    2
+            );
+
+            position = BarcodePosition.RIGHT;
+        }
+
+        return input;
+    }
+
+    public BarcodePosition getPos() {
+        return position;
+    }
+}
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/CVInitTest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/CVInitTest.java b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/CVInitTest.java
new file mode 100644
--- /dev/null	(date 1635979305909)
+++ b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/CVInitTest.java	(date 1635979305909)
@@ -0,0 +1,64 @@
+package org.firstinspires.ftc.teamcode;
+
+import com.qualcomm.robotcore.eventloop.opmode.TeleOp;
+
+import org.firstinspires.ftc.robotcore.external.hardware.camera.WebcamName;
+import org.openftc.easyopencv.OpenCvCamera;
+import org.openftc.easyopencv.OpenCvCameraFactory;
+import org.openftc.easyopencv.OpenCvCameraRotation;
+
+@TeleOp(name = "AutoCalibrate")
+public class CVInitTest extends TestTeleOpMode2 {
+
+    // Get webcam and create an OpenCvCamera
+    WebcamName wc;
+    OpenCvCamera camera;
+
+    // global obj
+    static final BarcodePipeline brp = new BarcodePipeline();
+
+
+    protected void onInitialize() {
+
+        // Init webcam and create a cam object using CvFactory
+        // Make sure to have the name of the webcam set in the config settings of the robot
+        int cameraMonitorViewId = hardwareMap.appContext.getResources().getIdentifier("cameraMonitorViewId", "id", hardwareMap.appContext.getPackageName());
+        wc = hardwareMap.get(WebcamName.class, "Webcam");
+
+        // W/ or W/ out live preview
+        camera = OpenCvCameraFactory.getInstance().createWebcam(wc, cameraMonitorViewId);
+        // camera = OpenCvCameraFactory.getInstance().createWebcam(wc);
+
+        camera.setPipeline(brp);
+
+        // Open an asynchronous connection to the device
+        camera.openCameraDeviceAsync(new OpenCvCamera.AsyncCameraOpenListener() {
+
+            // Start opening the camera and stream it
+            @Override
+            public void onOpened() {
+
+                /*
+                // create a rgb2gray mat pipeline
+                class GrayPipeline extends OpenCvPipeline {
+                    Mat gray = new Mat();
+                    @Override
+                    public Mat processFrame(Mat input) {
+                        // mat src, mat dst, int code, convert rgb img to gray
+                        Imgproc.cvtColor(input, gray, Imgproc.COLOR_RGB2GRAY);
+                        return gray;
+                    }
+                } */
+
+                camera.startStreaming(320, 240, OpenCvCameraRotation.UPRIGHT);
+            }
+
+            // Method will be called if the camera cannot be opened
+            @Override
+            public void onError(int errorCode) {
+                telemetry.addData("Camera Init Error", errorCode);
+            }
+        });
+    }
+    
+}
