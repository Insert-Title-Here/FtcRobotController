Index: TeamCode/src/main/java/teamcode/test/MasonTesting/DuckPipeline.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package teamcode.test.MasonTesting;\r\n\r\nimport static org.firstinspires.ftc.robotcore.external.BlocksOpModeCompanion.telemetry;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.HashMap;\r\nimport java.util.Scanner;\r\nimport java.util.Set;\r\nimport java.util.TreeMap;\r\nimport java.util.TreeSet;\r\n\r\nimport org.apache.commons.math3.geometry.euclidean.threed.Vector3D;\r\nimport org.checkerframework.checker.units.qual.A;\r\nimport org.opencv.core.Core;\r\nimport org.opencv.core.CvType;\r\nimport org.opencv.core.Mat;\r\nimport org.opencv.core.MatOfPoint;\r\nimport org.opencv.core.MatOfPoint2f;\r\nimport org.opencv.core.Point;\r\nimport org.opencv.core.Rect;\r\nimport org.opencv.core.Scalar;\r\nimport org.opencv.core.Size;\r\nimport org.opencv.imgcodecs.Imgcodecs;\r\nimport org.opencv.imgproc.Imgproc;\r\nimport org.opencv.utils.Converters;\r\nimport org.opencv.videoio.VideoCapture;\r\nimport org.openftc.easyopencv.OpenCvPipeline;\r\n\r\nimport teamcode.common.Debug;\r\n\r\npublic class DuckPipeline extends OpenCvPipeline {\r\n\r\n    private int direction;\r\n    private boolean duckCentered;\r\n    private ArrayList<MatOfPoint> contours, contourLengths;\r\n    private ArrayList<Integer> xList, yList;\r\n\r\n    private double xCenterMin, xCenterMax;\r\n    private final double deviation = 5;\r\n\r\n    private final Scalar lowerYellow = new Scalar(13, 130, 100);\r\n    private final Scalar upperYellow = new Scalar(29, 255, 255);\r\n\r\n    private final int blurSize = 7;\r\n\r\n    @Override\r\n    public Mat processFrame(Mat input) {\r\n        Mat frameHSV = new Mat();\r\n        Mat frameBlurred = new Mat();\r\n        Mat frameMasked = new Mat();\r\n        Mat frameBinary = new Mat();\r\n        contours = new ArrayList<>();\r\n        contourLengths = new ArrayList<>();\r\n\r\n        xCenterMin = input.width() / 2 - deviation;\r\n        xCenterMax = input.width() / 2 + deviation;\r\n\r\n        // blur the image\r\n        Imgproc.GaussianBlur(input, frameBlurred, new Size(blurSize, blurSize), 0);\r\n\r\n        // color space and masking\r\n        Imgproc.cvtColor(frameBlurred, frameHSV, Imgproc.COLOR_BGR2HSV);\r\n\r\n        // erosion and dilation for noise reduction\r\n        Imgproc.erode(frameMasked, frameMasked, new Mat(), new Point(-1, -1), 2);\r\n        Imgproc.dilate(frameMasked, frameMasked, new Mat(), new Point(-1, -1), 2);\r\n\r\n        // get the binarys of the image\r\n        Imgproc.threshold(frameMasked, frameBinary, 100, 255, Imgproc.THRESH_BINARY_INV);\r\n\r\n        // get contours and arc length\r\n        Imgproc.findContours(frameMasked, contours, new Mat(), Imgproc.RETR_EXTERNAL, Imgproc.CHAIN_APPROX_SIMPLE);\r\n\r\n        for (int i = 0; i < contours.size(); i++) {\r\n            double indexedLength = Imgproc.arcLength(new MatOfPoint2f(contours.get(i).toArray()), true);\r\n            if (indexedLength > 20) {\r\n                Debug.log(\"Current Length: \" + indexedLength);\r\n                contourLengths.add(contours.get(i));\r\n            }\r\n        }\r\n\r\n        Imgproc.drawContours(input, contourLengths, -1, new Scalar(255, 255, 255), 1, Imgproc.LINE_8);\r\n\r\n        frameHSV.release();\r\n        frameBlurred.release();\r\n        frameMasked.release();\r\n        frameBinary.release();\r\n        contours.clear();\r\n        contourLengths.clear();\r\n        return input;\r\n    }\r\n\r\n    public boolean isCentered() {\r\n        return duckCentered;\r\n    }\r\n\r\n    public double direction() {\r\n        return direction;\r\n    }\r\n\r\n    private void setDirection(int dir) {\r\n        direction = dir;\r\n    }\r\n\r\n    private void setCentered(boolean state) {\r\n        duckCentered = state;\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/TeamCode/src/main/java/teamcode/test/MasonTesting/DuckPipeline.java b/TeamCode/src/main/java/teamcode/test/MasonTesting/DuckPipeline.java
--- a/TeamCode/src/main/java/teamcode/test/MasonTesting/DuckPipeline.java	(revision 183b0a7a895e8187661be6ba39779130728cc9b2)
+++ b/TeamCode/src/main/java/teamcode/test/MasonTesting/DuckPipeline.java	(date 1646713475127)
@@ -31,7 +31,7 @@
 public class DuckPipeline extends OpenCvPipeline {
 
     private int direction;
-    private boolean duckCentered;
+    private boolean duckCentered = false;
     private ArrayList<MatOfPoint> contours, contourLengths;
     private ArrayList<Integer> xList, yList;
 
@@ -45,6 +45,9 @@
 
     @Override
     public Mat processFrame(Mat input) {
+        xList = new ArrayList<>();
+        yList = new ArrayList<>();
+
         Mat frameHSV = new Mat();
         Mat frameBlurred = new Mat();
         Mat frameMasked = new Mat();
@@ -59,7 +62,8 @@
         Imgproc.GaussianBlur(input, frameBlurred, new Size(blurSize, blurSize), 0);
 
         // color space and masking
-        Imgproc.cvtColor(frameBlurred, frameHSV, Imgproc.COLOR_BGR2HSV);
+        Imgproc.cvtColor(frameBlurred, frameHSV, Imgproc.COLOR_RGB2HSV);
+        Core.inRange(frameHSV, lowerYellow, upperYellow, frameMasked);
 
         // erosion and dilation for noise reduction
         Imgproc.erode(frameMasked, frameMasked, new Mat(), new Point(-1, -1), 2);
@@ -73,12 +77,43 @@
 
         for (int i = 0; i < contours.size(); i++) {
             double indexedLength = Imgproc.arcLength(new MatOfPoint2f(contours.get(i).toArray()), true);
-            if (indexedLength > 20) {
-                Debug.log("Current Length: " + indexedLength);
+            if (indexedLength >= 30 && indexedLength <= 220) {
                 contourLengths.add(contours.get(i));
             }
         }
 
+        xList.clear();
+        yList.clear();
+        for (int i = 0; i < contourLengths.size(); i++) {
+            ArrayList<Point> pointList = new ArrayList<>();
+            Converters.Mat_to_vector_Point(contourLengths.get(i), pointList);
+
+            for (Point p : pointList) {
+                xList.add((int) p.x);
+                yList.add((int) p.y);
+            }
+
+            int xMin = Integer.MAX_VALUE;
+            int xMax = Integer.MIN_VALUE;
+            for (int num : xList) {
+                if (num < xMin) {
+                    xMin = num;
+                }
+                if (num > xMax) {
+                    xMax = num;
+                }
+            }
+
+            double xCord = xMin + Math.abs((xMax - xMin) / 2);
+            if (xCord < xCenterMin) {
+                setDirection(-1);
+            } else if (xCord > xCenterMax) {
+                setDirection(1);
+            } else {
+                setCentered(true);
+                setDirection(0);
+            }
+        }
         Imgproc.drawContours(input, contourLengths, -1, new Scalar(255, 255, 255), 1, Imgproc.LINE_8);
 
         frameHSV.release();
@@ -87,6 +122,8 @@
         frameBinary.release();
         contours.clear();
         contourLengths.clear();
+        xList.clear();
+        yList.clear();
         return input;
     }
 
@@ -104,5 +141,6 @@
 
     private void setCentered(boolean state) {
         duckCentered = state;
+
     }
 }
Index: TeamCode/src/main/java/teamcode/test/MasonTesting/DuckCamera.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package teamcode.test.MasonTesting;\r\n\r\nimport com.qualcomm.robotcore.eventloop.opmode.Autonomous;\r\n\r\nimport teamcode.common.AbstractOpMode;\r\n\r\nimport org.firstinspires.ftc.robotcore.external.hardware.camera.WebcamName;\r\nimport org.openftc.easyopencv.OpenCvCamera;\r\nimport org.openftc.easyopencv.OpenCvCameraFactory;\r\nimport org.openftc.easyopencv.OpenCvCameraRotation;\r\n\r\n@Autonomous(name = \"DuckCamera\")\r\npublic class DuckCamera extends AbstractOpMode {\r\n\r\n    // TODO : Add MecanumDrive Classes and other external devices\r\n    WebcamName webcam;\r\n    OpenCvCamera camera;\r\n\r\n    DuckPipeline duckPip = new DuckPipeline();\r\n\r\n    @Override\r\n    protected void onInitialize() {\r\n        int cameraMonitorViewId = hardwareMap.appContext.getResources().getIdentifier(\"cameraMonitorViewId\", \"id\", hardwareMap.appContext.getPackageName());\r\n        webcam = hardwareMap.get(WebcamName.class, \"Webcam\");\r\n\r\n        camera = OpenCvCameraFactory.getInstance().createWebcam(webcam, cameraMonitorViewId);\r\n        camera.setPipeline(duckPip);\r\n\r\n        camera.openCameraDeviceAsync(new OpenCvCamera.AsyncCameraOpenListener() {\r\n            @Override\r\n            public void onOpened() {\r\n                camera.startStreaming(320, 240, OpenCvCameraRotation.UPRIGHT);\r\n            }\r\n\r\n            @Override\r\n            public void onError(int errorCode) {\r\n                telemetry.addData(\"Camera Init Error\", errorCode);\r\n            }\r\n        });\r\n    }\r\n\r\n    @Override\r\n    protected void onStart() {\r\n        // TODO : Add Movement Implementation\r\n        // duckPip.direction();\r\n        // duckPip.isCentered();\r\n\r\n\r\n    }\r\n\r\n    @Override\r\n    protected void onStop() {\r\n        camera.stopStreaming();\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/TeamCode/src/main/java/teamcode/test/MasonTesting/DuckCamera.java b/TeamCode/src/main/java/teamcode/test/MasonTesting/DuckCamera.java
--- a/TeamCode/src/main/java/teamcode/test/MasonTesting/DuckCamera.java	(revision 183b0a7a895e8187661be6ba39779130728cc9b2)
+++ b/TeamCode/src/main/java/teamcode/test/MasonTesting/DuckCamera.java	(date 1646713834895)
@@ -2,7 +2,11 @@
 
 import com.qualcomm.robotcore.eventloop.opmode.Autonomous;
 
+import teamcode.Competition.Subsystems.ArmSystem;
+import teamcode.Competition.Subsystems.EndgameSystems;
 import teamcode.common.AbstractOpMode;
+import teamcode.common.MecanumDriveTrain;
+import teamcode.common.Utils;
 
 import org.firstinspires.ftc.robotcore.external.hardware.camera.WebcamName;
 import org.openftc.easyopencv.OpenCvCamera;
@@ -13,13 +17,23 @@
 public class DuckCamera extends AbstractOpMode {
 
     // TODO : Add MecanumDrive Classes and other external devices
-    WebcamName webcam;
-    OpenCvCamera camera;
+
+    private final double VELOCITY = 10;
+    private EndgameSystems system;
+    private MecanumDriveTrain drive;
+    private ArmSystem arm;
 
-    DuckPipeline duckPip = new DuckPipeline();
+    private OpenCvCamera camera;
+    private WebcamName webcam;
+
+    private DuckPipeline duckPip = new DuckPipeline();
 
     @Override
     protected void onInitialize() {
+        arm = new ArmSystem(hardwareMap, false);
+        system = new EndgameSystems(hardwareMap, false);
+        drive = new MecanumDriveTrain(hardwareMap, true, system, arm);
+
         int cameraMonitorViewId = hardwareMap.appContext.getResources().getIdentifier("cameraMonitorViewId", "id", hardwareMap.appContext.getPackageName());
         webcam = hardwareMap.get(WebcamName.class, "Webcam");
 
@@ -35,21 +49,38 @@
             @Override
             public void onError(int errorCode) {
                 telemetry.addData("Camera Init Error", errorCode);
+                telemetry.update();
             }
         });
     }
 
     @Override
     protected void onStart() {
+        // camera.stopStreaming();
+
+//        drive.moveDistanceDEVelocity(300, 90, VELOCITY);
+//        Utils.sleep(1000);
+//        drive.moveDistanceDEVelocity(600, -90, VELOCITY);
+//        Utils.sleep(1000);
+//        drive.moveDistanceDEVelocity(300, 90, VELOCITY);
+//
+//        Utils.sleep(3000);
+        //drive.strafeDuck(duckPip.direction());
+
         // TODO : Add Movement Implementation
         // duckPip.direction();
         // duckPip.isCentered();
-
-
+        while (!duckPip.isCentered()) {
+            telemetry.addData("DIR: ", duckPip.direction());
+            telemetry.update();
+            drive.setStrafe(duckPip.direction());
+        }
     }
 
     @Override
     protected void onStop() {
+        drive.brake();
+        drive.cleanup();
         camera.stopStreaming();
     }
 }
Index: TeamCode/src/main/java/teamcode/common/MecanumDriveTrain.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+> package teamcode.common;\r\n\r\nimport com.qualcomm.hardware.bosch.BNO055IMU;\r\nimport com.qualcomm.hardware.bosch.JustLoggingAccelerationIntegrator;\r\nimport com.qualcomm.hardware.lynx.LynxModule;\r\nimport com.qualcomm.robotcore.hardware.DcMotor;\r\nimport com.qualcomm.robotcore.hardware.DcMotorEx;\r\nimport com.qualcomm.robotcore.hardware.DcMotorSimple;\r\nimport com.qualcomm.robotcore.hardware.DistanceSensor;\r\nimport com.qualcomm.robotcore.hardware.HardwareMap;\r\nimport com.qualcomm.robotcore.hardware.NormalizedColorSensor;\r\nimport com.qualcomm.robotcore.hardware.NormalizedRGBA;\r\nimport com.qualcomm.robotcore.hardware.PIDFCoefficients;\r\n\r\nimport org.firstinspires.ftc.robotcore.external.navigation.AngleUnit;\r\nimport org.firstinspires.ftc.robotcore.external.navigation.DistanceUnit;\r\nimport org.openftc.revextensions2.ExpansionHubEx;\r\nimport org.openftc.revextensions2.ExpansionHubMotor;\r\nimport org.openftc.revextensions2.RevBulkData;\r\n\r\nimport java.util.ArrayList;\r\n\r\nimport teamcode.Competition.Subsystems.ArmSystem;\r\nimport teamcode.Competition.Subsystems.EndgameSystems;\r\nimport teamcode.test.MasonTesting.CvDetectionPipeline;\r\n\r\npublic class MecanumDriveTrain {\r\n    private static final double ANGULAR_TOLERANCE = 0.05;\r\n    final double COUNTS_PER_INCH = 920.111004;\r\n\r\n    /*\r\n    This has most of the relevant information regarding a 4 wheel Mecanum DriveTrain,\r\n    which is the most used DriveTrain in FTC\r\n     */\r\n\r\n    private DcMotorEx fl, fr, bl, br;\r\n    private BNO055IMU imu;\r\n    Localizer localizer;\r\n    EndgameSystems systems;\r\n    Vector2D previousVelocity;\r\n    Vector2D previousError;\r\n    double previousOmegaError;\r\n    private NormalizedColorSensor sensor, warehouse;\r\n    ArmSystem arm;\r\n\r\n    NormalizedColorSensor frontRed, backRed, frontBlue, backBlue;\r\n\r\n\r\n    LynxModule hub;\r\n\r\n\r\n    private boolean environmentalTerminate, eStop;\r\n    private boolean isRed;\r\n    private volatile boolean[] flags;\r\n\r\n\r\n    /**\r\n     * PID Constants\r\n     *\r\n     */\r\n    final double pVelocity = 0.000725; //0.000725\r\n    final double dVelocity  = 0.0; //0.027\r\n    final double FEEDFORWARD_PID = 0.2;\r\n\r\n    //todo for optimizing is to tune the PID aggresively due to high accel\r\n    //todo is necessary to retune due to the rework of voltage to velocity\r\n\r\n    public MecanumDriveTrain(HardwareMap hardwareMap){\r\n        fl = (ExpansionHubMotor) hardwareMap.dcMotor.get(\"FrontLeftDrive\");\r\n        fr = (ExpansionHubMotor) hardwareMap.dcMotor.get(\"FrontRightDrive\");\r\n        bl = (ExpansionHubMotor) hardwareMap.dcMotor.get(\"BackLeftDrive\");\r\n        br = (ExpansionHubMotor) hardwareMap.dcMotor.get(\"BackRightDrive\");\r\n        correctMotors();\r\n\r\n    }\r\n\r\n    public MecanumDriveTrain(HardwareMap hardwareMap, Localizer localizer, boolean isRed){\r\n        fl = (ExpansionHubMotor) hardwareMap.dcMotor.get(\"FrontLeftDrive\");\r\n        fr = (ExpansionHubMotor) hardwareMap.dcMotor.get(\"FrontRightDrive\");\r\n        bl = (ExpansionHubMotor) hardwareMap.dcMotor.get(\"BackLeftDrive\");\r\n        br = (ExpansionHubMotor) hardwareMap.dcMotor.get(\"BackRightDrive\");\r\n\r\n\r\n        this.localizer = localizer;\r\n        previousVelocity = new Vector2D(0,0);\r\n        previousOmega = 0;\r\n        correctMotors();\r\n        this.isRed = isRed;\r\n\r\n    }\r\n\r\n    /**\r\n     * drive encoder constructor with Modular PIDF controller constants, for seperate opModes\r\n     */\r\n    public MecanumDriveTrain(HardwareMap hardwareMap, boolean isRed, EndgameSystems systems, ArmSystem arm, PIDFCoefficients coefficients){\r\n        BNO055IMU.Parameters parameters = new BNO055IMU.Parameters();\r\n        parameters.angleUnit           = BNO055IMU.AngleUnit.RADIANS;\r\n        parameters.accelUnit           = BNO055IMU.AccelUnit.METERS_PERSEC_PERSEC;\r\n        parameters.calibrationDataFile = \"BNO055IMUCalibration.json\"; // see the calibration sample opmode\r\n        parameters.loggingEnabled      = true;\r\n        parameters.loggingTag          = \"IMU\";\r\n        parameters.accelerationIntegrationAlgorithm = new JustLoggingAccelerationIntegrator();\r\n\r\n        imu = hardwareMap.get(BNO055IMU.class, \"imu\");\r\n        imu.initialize(parameters);\r\n        this.isRed = isRed;\r\n        this.systems = systems;\r\n\r\n        fl = hardwareMap.get(DcMotorEx.class, \"FrontLeftDrive\");\r\n        fr = hardwareMap.get(DcMotorEx.class, \"FrontRightDrive\");\r\n        bl = hardwareMap.get(DcMotorEx.class, \"BackLeftDrive\");\r\n        br = hardwareMap.get(DcMotorEx.class, \"BackRightDrive\");\r\n        this.arm = arm;\r\n\r\n        frontRed = hardwareMap.get(NormalizedColorSensor.class, \"FrontColorSensorRed\");\r\n        backRed = hardwareMap.get(NormalizedColorSensor.class, \"BackColorSensorRed\");\r\n        frontBlue = hardwareMap.get(NormalizedColorSensor.class, \"FrontColorSensorBlue\");\r\n        backBlue = hardwareMap.get(NormalizedColorSensor.class, \"BackColorSensorBlue\");\r\n        warehouse = hardwareMap.get(NormalizedColorSensor.class, \"WarehouseTapeSensor\");\r\n        sensor = hardwareMap.get(NormalizedColorSensor.class, \"color\");\r\n\r\n        warehouse.setGain(600);\r\n        frontRed.setGain(100);\r\n        backRed.setGain(420);\r\n        frontBlue.setGain(600);\r\n        backBlue.setGain(300);\r\n        sensor.setGain(950); //325 is tested value but i think I trust this one more //280\r\n\r\n        flags = new boolean[]{false, false, false, false, false};\r\n\r\n\r\n        hub = hardwareMap.get(LynxModule.class, \"Control Hub\");\r\n        hub.setBulkCachingMode(LynxModule.BulkCachingMode.MANUAL);\r\n\r\n\r\n        previousVelocity = new Vector2D(0,0);\r\n        previousOmega = 0;\r\n        correctMotors();\r\n        setPIDFCoefficients(coefficients);\r\n\r\n\r\n    }\r\n\r\n    public MecanumDriveTrain(HardwareMap hardwareMap, boolean isRed, EndgameSystems systems, ArmSystem arm){\r\n        this(hardwareMap, isRed, systems, arm, new PIDFCoefficients(2.5, 0.5, 1.0, 0));\r\n\r\n    }\r\n\r\n\r\n    public synchronized void rotateDistanceDERadian(double radians, double omega){\r\n        double deltaRadians = radians - imu.getAngularOrientation().firstAngle;\r\n        double startAngle = imu.getAngularOrientation().firstAngle;\r\n        omega *= -getSign(deltaRadians);\r\n        setEncoderMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n        setEncoderMode(DcMotor.RunMode.RUN_USING_ENCODER);\r\n        while(Math.abs(startAngle - imu.getAngularOrientation().firstAngle) < Math.abs(deltaRadians)){\r\n            setMotorVelocity(omega, -omega, omega, -omega);\r\n        }\r\n        brake();\r\n    }\r\n\r\n    public synchronized void rotateDistanceDE(double degrees, double omega){\r\n        double radians = Math.toRadians(degrees);\r\n        rotateDistanceDERadian(radians, omega);\r\n    }\r\n\r\n    public void driveColorSensorWarehouse(double velocity){\r\n        NormalizedRGBA rgba = warehouse.getNormalizedColors();\r\n        setEncoderMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n        setEncoderMode(DcMotor.RunMode.RUN_USING_ENCODER);\r\n        while(rgba.red < 0.9){\r\n            rgba = warehouse.getNormalizedColors();\r\n            setMotorVelocity(velocity,velocity,velocity,velocity);\r\n        }\r\n        brake();\r\n    }\r\n\r\n\r\n    public void spinDuck(boolean blue){\r\n        systems.setCarouselMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n        systems.setCarouselMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\r\n\r\n        int pose = -25000;\r\n        double direction;\r\n        DcMotor carouselEncoder;\r\n        if(blue){\r\n            carouselEncoder = systems.getBlueCarouselEncoder();\r\n            direction = -1;\r\n        }else {\r\n            direction = 1;\r\n            carouselEncoder = systems.getRedCarouselEncoder();\r\n        }\r\n        pose *= direction;\r\n\r\n        carouselEncoder.setTargetPosition(pose);\r\n        carouselEncoder.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        while(Math.abs(carouselEncoder.getCurrentPosition()) < Math.abs(carouselEncoder.getTargetPosition()) && AbstractOpMode.currentOpMode().opModeIsActive()){\r\n            if(Math.abs(carouselEncoder.getCurrentPosition()) < 100) {\r\n            setStrafe(0.02);\r\n            }else{\r\n                brake();\r\n            }\r\n\r\n            if(Math.abs(carouselEncoder.getCurrentPosition()) < 10000){\r\n                systems.runCarousel(0.1 * direction);\r\n            }else{\r\n                systems.runCarousel(0.5 * direction);\r\n                systems.runCarousel(0.5 * direction);\r\n\r\n            }\r\n            AbstractOpMode.currentOpMode().telemetry.addData(\"curr\", carouselEncoder.getCurrentPosition());\r\n            AbstractOpMode.currentOpMode().telemetry.addData(\"tar\", carouselEncoder.getTargetPosition());\r\n            AbstractOpMode.currentOpMode().telemetry.update();\r\n\r\n        }\r\n        systems.runCarousel(0);\r\n        carouselEncoder.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\r\n    }\r\n\r\n\r\n    public double getAngle(){\r\n        return imu.getAngularOrientation().firstAngle;\r\n    }\r\n\r\n    /**\r\n     * makes the drive move in an omnidirectional vector of the users choice\r\n     * @param distance tics magnitude of the vector\r\n     * @param degrees degrees that the vector should be rotated relative to the robots definiton of front, (rotation of 0 makes the robot drive all 4 wheels straight intake side facing)\r\n     * @param power voltage, always should be positive\r\n     * @param omega voltage, always should be positive\r\n     */\r\n    public synchronized void moveDistanceDE(int distance, double degrees, double power, double omega){\r\n        double radians = Math.toRadians(degrees);\r\n        power *= getSign(distance);\r\n        Vector2D vec = Vector2D.fromAngleMagnitude(radians, power);\r\n        double globalHeading = imu.getAngularOrientation().firstAngle;\r\n        radians = radians + (Math.PI / 4.0) ; //45deg + globalHeading\r\n        int flDistance = (int)(Math.sin(radians) * distance);\r\n        int frDistance = (int)(Math.cos(radians) * distance);\r\n        int blDistance = (int)(Math.cos(radians) * distance);\r\n        int brDistance = (int)(Math.sin(radians) * distance);\r\n        setEncoderMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n        setEncoderMode(DcMotor.RunMode.RUN_USING_ENCODER);\r\n\r\n\r\n\r\n\r\n\r\n        LynxModule.BulkData data = hub.getBulkData();\r\n        //AbstractOpMode.currentOpMode().telemetry.addData(\"fl\", data.getMotorCurrentPosition(0));\r\n        AbstractOpMode.currentOpMode().telemetry.addData(\"fl\", flDistance);\r\n        //AbstractOpMode.currentOpMode().telemetry.addData(\"fr\", data.getMotorCurrentPosition(1));\r\n        AbstractOpMode.currentOpMode().telemetry.addData(\"fr\", frDistance);\r\n        //AbstractOpMode.currentOpMode().telemetry.addData(\"bl\", data.getMotorCurrentPosition(2));\r\n        AbstractOpMode.currentOpMode().telemetry.addData(\"bl\", blDistance);\r\n        //AbstractOpMode.currentOpMode().telemetry.addData(\"br\", data.getMotorCurrentPosition(3));\r\n        AbstractOpMode.currentOpMode().telemetry.addData(\"br\", brDistance);\r\n        AbstractOpMode.currentOpMode().telemetry.update();\r\n\r\n        while((Math.abs(data.getMotorCurrentPosition(0)) < Math.abs(flDistance) && Math.abs(data.getMotorCurrentPosition(1)) < Math.abs(frDistance)\r\n        && Math.abs(data.getMotorCurrentPosition(2)) < Math.abs(blDistance) && Math.abs(data.getMotorCurrentPosition(3)) < Math.abs(brDistance))){\r\n            hub.clearBulkCache();\r\n            data = hub.getBulkData();\r\n            AbstractOpMode.currentOpMode().telemetry.addData(\"fl\",- data.getMotorCurrentPosition(0));\r\n            //AbstractOpMode.currentOpMode().telemetry.addData(\"fl\", flDistance);\r\n            AbstractOpMode.currentOpMode().telemetry.addData(\"fr\", data.getMotorCurrentPosition(1));\r\n            //AbstractOpMode.currentOpMode().telemetry.addData(\"fr\", frDistance);\r\n            AbstractOpMode.currentOpMode().telemetry.addData(\"bl\", -data.getMotorCurrentPosition(2));\r\n            //AbstractOpMode.currentOpMode().telemetry.addData(\"bl\", blDistance);\r\n            AbstractOpMode.currentOpMode().telemetry.addData(\"br\", data.getMotorCurrentPosition(3));\r\n            //AbstractOpMode.currentOpMode().telemetry.addData(\"br\", brDistance);\r\n            AbstractOpMode.currentOpMode().telemetry.update();\r\n            setPower(vec, 0);\r\n        }\r\n\r\n        brake();\r\n        rotateDistanceDERadian(globalHeading, omega);\r\n    }\r\n\r\n    private void setPIDFCoefficients(PIDFCoefficients coefficients){\r\n        fl.setPIDFCoefficients(DcMotor.RunMode.RUN_USING_ENCODER, coefficients);\r\n        fr.setPIDFCoefficients(DcMotor.RunMode.RUN_USING_ENCODER, coefficients);\r\n        bl.setPIDFCoefficients(DcMotor.RunMode.RUN_USING_ENCODER, coefficients);\r\n        br.setPIDFCoefficients(DcMotor.RunMode.RUN_USING_ENCODER, coefficients);\r\n    }\r\n\r\n    /**\r\n     * movement in any translational direction reaching any desired velocity\r\n     * @param distance is measured in rotational encoder tics,\r\n     * this is to simplify the method implementation\r\n     *\r\n     * @param degrees the angle the robot should be travelling at in DEGREES,\r\n     * this parameter should be passed [-180, 180]\r\n     * KEY FOR THIS PARAMETER\r\n     * 0, Drive straight\r\n     * 90, strafe right\r\n     * 180, drive backwards\r\n     * -90, strafe left\r\n     * any number in between is a diagonal in that quadrant.\r\n     *\r\n     * @param velocity the linear velocity in inches per second that the robot should travel\r\n     */\r\n    public synchronized void moveDistanceDEVelocity(int distance, double degrees, double velocity){\r\n        double radians = Math.toRadians(degrees);\r\n        velocity *= getSign(distance);\r\n        Vector2D vec = Vector2D.fromAngleMagnitude(radians, velocity);\r\n        radians = radians + (Math.PI / 4.0) ; //45deg + globalHeading\r\n        int flDistance = (int)(Math.sin(radians) * distance);\r\n        int frDistance = (int)(Math.cos(radians) * distance);\r\n        int blDistance = (int)(Math.cos(radians) * distance);\r\n        int brDistance = (int)(Math.sin(radians) * distance);\r\n\r\n        setEncoderMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n        setEncoderMode(DcMotor.RunMode.RUN_USING_ENCODER);\r\n        hub.clearBulkCache();\r\n        LynxModule.BulkData data = hub.getBulkData();\r\n        while(Math.abs(data.getMotorCurrentPosition(0))< Math.abs(flDistance) || Math.abs(data.getMotorCurrentPosition(1)) < Math.abs(frDistance) ||\r\n                Math.abs(data.getMotorCurrentPosition(2)) < Math.abs(blDistance) || Math.abs(data.getMotorCurrentPosition(3)) < Math.abs(brDistance)){\r\n            hub.clearBulkCache();\r\n            data = hub.getBulkData();\r\n            AbstractOpMode.currentOpMode().telemetry.addData(\"fl\",data.getMotorCurrentPosition(0));\r\n            AbstractOpMode.currentOpMode().telemetry.addData(\"fl\", flDistance);\r\n            AbstractOpMode.currentOpMode().telemetry.addData(\"fr\", data.getMotorCurrentPosition(1));\r\n            AbstractOpMode.currentOpMode().telemetry.addData(\"fr\", frDistance);\r\n            AbstractOpMode.currentOpMode().telemetry.addData(\"bl\", data.getMotorCurrentPosition(2));\r\n            AbstractOpMode.currentOpMode().telemetry.addData(\"bl\", blDistance);\r\n            AbstractOpMode.currentOpMode().telemetry.addData(\"br\", data.getMotorCurrentPosition(3));\r\n            AbstractOpMode.currentOpMode().telemetry.addData(\"br\", brDistance);\r\n            AbstractOpMode.currentOpMode().telemetry.update();\r\n\r\n            setVelocity(vec, 0);\r\n        }\r\n        brake();\r\n    }\r\n\r\n\r\n    public synchronized void driveColorSensor(double pow){\r\n        setEncoderMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n        setEncoderMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\r\n        arm.lowerLinkage();\r\n        arm.intakeDumb(1.0);\r\n        boolean detectedElement = false;\r\n        Utils.sleep(100);\r\n        setMotorVelocity(pow,pow,pow,pow);\r\n        Utils.sleep(250);\r\n        while(!detectedElement){\r\n//            Vector2D vec = Vector2D.fromAngleMagnitude(0, pow);\r\n//            setEncoderMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n//            setEncoderMode(DcMotor.RunMode.RUN_USING_ENCODER);\r\n//            hub.clearBulkCache();\r\n//            LynxModule.BulkData data = hub.getBulkData();\r\n//            while(Math.abs(data.getMotorCurrentPosition(0))< Math.abs(200) || Math.abs(data.getMotorCurrentPosition(1)) < Math.abs(200) ||\r\n//                    Math.abs(data.getMotorCurrentPosition(2)) < Math.abs(200) || Math.abs(data.getMotorCurrentPosition(3)) < Math.abs(200)){\r\n//                hub.clearBulkCache();\r\n//                data = hub.getBulkData();\r\n                setMotorVelocity(pow,pow,pow,pow);\r\n                NormalizedRGBA colors = sensor.getNormalizedColors();\r\n                double red = colors.red;\r\n                double blue = colors.blue;\r\n                double green = colors.green;\r\n                AbstractOpMode.currentOpMode().telemetry.addData(\"green\", green);\r\n                AbstractOpMode.currentOpMode().telemetry.addData(\"red\", red);\r\n                AbstractOpMode.currentOpMode().telemetry.addData(\"blue\", blue);\r\n                AbstractOpMode.currentOpMode().telemetry.update();\r\n\r\n                if (red > 0.9) {\r\n                    detectedElement = true;\r\n                    break;\r\n                } else {\r\n                    detectedElement = false;\r\n                }\r\n                //setVelocity(vec, 0);\r\n            //}\r\n        }\r\n        brake();\r\n        AbstractOpMode.currentOpMode().telemetry.clear();\r\n        Debug.log(\"grabbed\");\r\n        hub.clearBulkCache();\r\n        LynxModule.BulkData data = hub.getBulkData();\r\n        double posAvg = 0;\r\n        for(int i = 0; i < 4; i++){\r\n            int pos = Math.abs(data.getMotorCurrentPosition(i));\r\n            Debug.log(pos);\r\n            posAvg += pos;\r\n        }\r\n        posAvg = posAvg / (4.0 * 0.707); //4 cos 45\r\n        arm.preScoreAuto();\r\n        arm.intakeDumb(-1.0);\r\n//        posAvg -= 600;\r\n//        if(posAvg < 600){\r\n//            posAvg = 0;\r\n//        }\r\n\r\n        ArrayList<Movement> spline = new ArrayList<>();\r\n        double sign = 1;\r\n        if(!isRed){\r\n            sign = -1;\r\n        }\r\n        moveDistanceDEVelocity(200, 180, 9);\r\n        strafeDistanceSensor(6, 0);\r\n        driveColorSensorWarehouse(-9);\r\n        moveDistanceDEVelocity(300, 180,9);\r\n        //moveDistanceDEVelocity((int)((posAvg) / Math.cos(Math.toRadians(10))), 170 * sign, 9);\r\n//        spline.add(new Movement(200, 3,180));\r\n//        spline.add(new Movement((int)(posAvg / Math.cos(10)), 3, 170));\r\n//        splicedMovement(spline);\r\n        //Debug.log(\"val\" + (int)((posAvg) / Math.cos(Math.toRadians(10))));\r\n\r\n        arm.intakeDumb(0);\r\n    }\r\n    public synchronized void driveColorSensorSpliced(double pow){\r\n        setEncoderMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n        setEncoderMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\r\n        arm.lowerLinkage();\r\n        arm.intakeDumb(1.0);\r\n        boolean detectedElement = false;\r\n        Utils.sleep(100);\r\n        setMotorVelocity(pow,pow,pow,pow);\r\n        Utils.sleep(250);\r\n        while(!detectedElement){\r\n//            Vector2D vec = Vector2D.fromAngleMagnitude(0, pow);\r\n//            setEncoderMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n//            setEncoderMode(DcMotor.RunMode.RUN_USING_ENCODER);\r\n//            hub.clearBulkCache();\r\n//            LynxModule.BulkData data = hub.getBulkData();\r\n//            while(Math.abs(data.getMotorCurrentPosition(0))< Math.abs(200) || Math.abs(data.getMotorCurrentPosition(1)) < Math.abs(200) ||\r\n//                    Math.abs(data.getMotorCurrentPosition(2)) < Math.abs(200) || Math.abs(data.getMotorCurrentPosition(3)) < Math.abs(200)){\r\n//                hub.clearBulkCache();\r\n//                data = hub.getBulkData();\r\n            setMotorVelocity(pow,pow,pow,pow);\r\n            NormalizedRGBA colors = sensor.getNormalizedColors();\r\n            double red = colors.red;\r\n            double blue = colors.blue;\r\n            double green = colors.green;\r\n            AbstractOpMode.currentOpMode().telemetry.addData(\"green\", green);\r\n            AbstractOpMode.currentOpMode().telemetry.addData(\"red\", red);\r\n            AbstractOpMode.currentOpMode().telemetry.addData(\"blue\", blue);\r\n            AbstractOpMode.currentOpMode().telemetry.update();\r\n\r\n            if (red > 0.9) {\r\n                detectedElement = true;\r\n                break;\r\n            } else {\r\n                detectedElement = false;\r\n            }\r\n            //setVelocity(vec, 0);\r\n            //}\r\n        }\r\n        brake();\r\n        AbstractOpMode.currentOpMode().telemetry.clear();\r\n        Debug.log(\"grabbed\");\r\n        hub.clearBulkCache();\r\n        LynxModule.BulkData data = hub.getBulkData();\r\n        double posAvg = 0;\r\n        for(int i = 0; i < 4; i++){\r\n            int pos = Math.abs(data.getMotorCurrentPosition(i));\r\n            Debug.log(pos);\r\n            posAvg += pos;\r\n        }\r\n        posAvg = posAvg / (4.0 * 0.707); //4 cos 45\r\n        arm.preScoreAuto();\r\n        arm.intakeDumb(-1.0);\r\n//        posAvg -= 600;\r\n//        if(posAvg < 600){\r\n//            posAvg = 0;\r\n//        }\r\n\r\n        ArrayList<Movement> spline = new ArrayList<>();\r\n        double sign = 1;\r\n        if(!isRed){\r\n            sign = -1;\r\n        }\r\n\r\n        arm.intakeDumb(0);\r\n    }\r\n\r\n    public void semiDumbVisionDriving(double pow){\r\n        while(!somethingInThePartition()){ //add the  conditional with something in the partition\r\n            setStrafe(pow);\r\n        }\r\n        setEncoderMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n        setEncoderMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\r\n        boolean detectedElement = false;\r\n        while(!detectedElement){\r\n            arm.lowerLinkage();\r\n            arm.intakeDumb(1.0);\r\n            NormalizedRGBA colors = sensor.getNormalizedColors();\r\n            double green = colors.green;\r\n            if (green > 0.9) {\r\n                detectedElement = true;\r\n            } else {\r\n                detectedElement = false;\r\n            }\r\n            setPower(pow, pow, pow, pow);\r\n        }\r\n        hub.clearBulkCache();\r\n        LynxModule.BulkData data = hub.getBulkData();\r\n        int posAvg = 0;\r\n        for(int i = 0; i < 4; i++){\r\n            int pos = data.getMotorCurrentPosition(i);\r\n            posAvg += pos;\r\n        }\r\n        posAvg = posAvg / 4;\r\n        moveDistanceDEVelocity(-posAvg, 0, 6);\r\n        strafeDistanceSensor(0.3, 0);\r\n    }\r\n    private boolean somethingInThePartition(){\r\n        //replace this with something that actually works Mason\r\n        return true;\r\n    }\r\n    public void SmartVisionDriving(double pow, Object pipeline){\r\n        double theta = 0;\r\n        pipeline.getClass(); //getThetaValue()\r\n        int tics = inchesToTics();\r\n        theta += Math.toRadians(5);\r\n        moveDistanceDE(tics, theta, pow, 0);\r\n        setEncoderMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n        setEncoderMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\r\n        boolean detectedElement = false;\r\n        while(!detectedElement){\r\n            arm.lowerLinkage();\r\n            arm.intakeDumb(1.0);\r\n            NormalizedRGBA colors = sensor.getNormalizedColors();\r\n            double green = colors.green;\r\n            if (green > 0.9) {\r\n                detectedElement = true;\r\n            } else {\r\n                detectedElement = false;\r\n            }\r\n            setPower(pow, pow, pow, pow);\r\n        }\r\n        hub.clearBulkCache();\r\n        LynxModule.BulkData data = hub.getBulkData();\r\n        int posAvg = 0;\r\n        for(int i = 0; i < 4; i++){\r\n            int pos = data.getMotorCurrentPosition(i);\r\n            posAvg += pos;\r\n        }\r\n        posAvg = posAvg / 4;\r\n        double secondDistance = tics * Math.cos(theta);\r\n        moveDistanceDEVelocity(-(int)(posAvg + secondDistance), 0, 6);\r\n        strafeDistanceSensor(0.3, 0);\r\n    }\r\n    private int inchesToTics(){\r\n        return 0;\r\n        //TODO import this from localizer\r\n    }\r\n\r\n\r\n\r\n\r\n    public synchronized void moveDistanceDENoErrorCorrection(int distance, double degrees, double power){\r\n        double radians = Math.toRadians(degrees);\r\n        power *= getSign(distance);\r\n        Vector2D vec = Vector2D.fromAngleMagnitude(radians, power);\r\n        double globalHeading = imu.getAngularOrientation().firstAngle;\r\n        radians = radians + (Math.PI / 4.0) ; //45deg + globalHeading\r\n        int flDistance = (int)(Math.sin(radians) * distance);\r\n        int frDistance = (int)(Math.cos(radians) * distance);\r\n        int blDistance = (int)(Math.cos(radians) * distance);\r\n        int brDistance = (int)(Math.sin(radians) * distance);\r\n        setEncoderMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n        setEncoderMode(DcMotor.RunMode.RUN_USING_ENCODER);\r\n\r\n\r\n\r\n        LynxModule.BulkData data = hub.getBulkData();\r\n        //AbstractOpMode.currentOpMode().telemetry.addData(\"fl\", data.getMotorCurrentPosition(0));\r\n        AbstractOpMode.currentOpMode().telemetry.addData(\"fl\", flDistance);\r\n        //AbstractOpMode.currentOpMode().telemetry.addData(\"fr\", data.getMotorCurrentPosition(1));\r\n        AbstractOpMode.currentOpMode().telemetry.addData(\"fr\", frDistance);\r\n        //AbstractOpMode.currentOpMode().telemetry.addData(\"bl\", data.getMotorCurrentPosition(2));\r\n        AbstractOpMode.currentOpMode().telemetry.addData(\"bl\", blDistance);\r\n        //AbstractOpMode.currentOpMode().telemetry.addData(\"br\", data.getMotorCurrentPosition(3));\r\n        AbstractOpMode.currentOpMode().telemetry.addData(\"br\", brDistance);\r\n        AbstractOpMode.currentOpMode().telemetry.update();\r\n\r\n        while((Math.abs(data.getMotorCurrentPosition(0)) < Math.abs(flDistance) && Math.abs(data.getMotorCurrentPosition(1)) < Math.abs(frDistance)\r\n                && Math.abs(data.getMotorCurrentPosition(2)) < Math.abs(blDistance) && Math.abs(data.getMotorCurrentPosition(3)) < Math.abs(brDistance))){\r\n            hub.clearBulkCache();\r\n            data = hub.getBulkData();\r\n            AbstractOpMode.currentOpMode().telemetry.addData(\"fl\",- data.getMotorCurrentPosition(0));\r\n            //AbstractOpMode.currentOpMode().telemetry.addData(\"fl\", flDistance);\r\n            AbstractOpMode.currentOpMode().telemetry.addData(\"fr\", data.getMotorCurrentPosition(1));\r\n            //AbstractOpMode.currentOpMode().telemetry.addData(\"fr\", frDistance);\r\n            AbstractOpMode.currentOpMode().telemetry.addData(\"bl\", -data.getMotorCurrentPosition(2));\r\n            //AbstractOpMode.currentOpMode().telemetry.addData(\"bl\", blDistance);\r\n            AbstractOpMode.currentOpMode().telemetry.addData(\"br\", data.getMotorCurrentPosition(3));\r\n            //AbstractOpMode.currentOpMode().telemetry.addData(\"br\", brDistance);\r\n            AbstractOpMode.currentOpMode().telemetry.update();\r\n\r\n\r\n            setPower(vec, 0);\r\n        }\r\n\r\n        brake();\r\n    }\r\n\r\n    public void cleanup(){\r\n\r\n        imu.close();\r\n        hub.clearBulkCache();\r\n\r\n    }\r\n\r\n    public void setEncoderMode(DcMotor.RunMode runMode){\r\n        fl.setMode(runMode);\r\n        fr.setMode(runMode);\r\n        bl.setMode(runMode);\r\n        br.setMode(runMode);\r\n    }\r\n\r\n\r\n\r\n    public MecanumDriveTrain(HardwareMap hardwareMap, Localizer localizer, boolean isRed, EndgameSystems systems){\r\n        this(hardwareMap, localizer, isRed);\r\n        this.systems = systems;\r\n    }\r\n\r\n    CvDetectionPipeline pipeline;\r\n\r\n    public MecanumDriveTrain(HardwareMap hardwareMap, Localizer localizer, CvDetectionPipeline pipeline, boolean isRed){\r\n        //this(hardwareMap, localizer, isRed);\r\n        this.pipeline = pipeline;\r\n    }\r\n/*\r\n        fl = (ExpansionHubMotor) hardwareMap.dcMotor.get(\"FrontLeftDrive\");\r\n        fr = (ExpansionHubMotor) hardwareMap.dcMotor.get(\"FrontRightDrive\");\r\n        bl = (ExpansionHubMotor) hardwareMap.dcMotor.get(\"BackLeftDrive\");\r\n        br = (ExpansionHubMotor) hardwareMap.dcMotor.get(\"BackRightDrive\");\r\n\r\n        this.localizer = localizer;\r\n        previousVelocity = new Vector2D(0,0);\r\n        previousOmega = 0;\r\n        correctMotors();\r\n\r\n */\r\n\r\n    public synchronized void smartDuck(boolean blue){\r\n        systems.setCarouselMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n        systems.setCarouselMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\r\n        double direction;\r\n        if(blue){\r\n            direction = -1;\r\n        }else{\r\n            direction = 1;\r\n        }\r\n        systems.runCarousel(-0.1);\r\n        Utils.sleep(100);\r\n        double currentTicks = systems.getCarouselPos();\r\n        double previousTicks = 0;\r\n        while(Math.abs(currentTicks - previousTicks) > 50){\r\n            currentTicks = systems.getCarouselPos();\r\n            setStrafe(0.2 * direction);\r\n            previousTicks = currentTicks;\r\n            AbstractOpMode.currentOpMode().telemetry.addData(\"dc\", currentTicks - previousTicks);\r\n            AbstractOpMode.currentOpMode().telemetry.addData(\"why\", systems.getCarouselPos());\r\n            AbstractOpMode.currentOpMode().telemetry.update();\r\n        }\r\n        Utils.sleep(250);\r\n        setStrafe(0);\r\n        while(Math.abs(currentTicks - previousTicks) < 50){\r\n            previousTicks = currentTicks;\r\n            currentTicks = systems.getCarouselPos();\r\n            setStrafe(-0.2 * direction);\r\n            AbstractOpMode.currentOpMode().telemetry.addData(\"dc\", Math.abs(currentTicks - previousTicks));\r\n            AbstractOpMode.currentOpMode().telemetry.addData(\"why\", systems.getCarouselPos());\r\n            AbstractOpMode.currentOpMode().telemetry.update();\r\n        }\r\n        setStrafe(0);\r\n        AbstractOpMode.currentOpMode().telemetry.clear();\r\n\r\n        systems.runCarousel(0);\r\n        systems.scoreDuckAuto();\r\n    }\r\n\r\n    /**\r\n     * DO NOT CALL THIS W/O ALL THE RIGHT CONSTRUCTORS\r\n     * @param desiredVelocity\r\n     * @param desiredRotate\r\n     */\r\n    public void seekCubes(double desiredVelocity, double desiredRotate){\r\n        if(pipeline == null || localizer == null){\r\n            return;\r\n        }\r\n        RobotPositionStateUpdater.RobotPositionState currentState = localizer.getCurrentState();\r\n        Vector2D robotPosition;\r\n        seekCubesRotate(desiredRotate);\r\n        Vector2D desiredPosition;\r\n        environmentalTerminate = false;\r\n        while(pipeline.yPointList().get(0) < 5 && AbstractOpMode.currentOpMode().opModeIsActive() && !eStop && !environmentalTerminate) { //todo ask mason how to ensure I am tracking the same cube every time here\r\n            //todo idea about above, write a method that traverses the stack by placing it in an arrayList, calculating the smallest deviation from the originally stored value and assuming that is the target,\r\n            //this would dynamically adapt to the closest cube in the frame may cause some oscillation especially during the rotational phase.\r\n            currentState = localizer.getCurrentState();\r\n            robotPosition = new Vector2D(currentState.getPosition().getX(), currentState.getPosition().getY());\r\n\r\n            Vector2D cubeToRobotDisplacement = new Vector2D(pipeline.xPointList().get(0), pipeline.yPointList().get(0));\r\n            double cubeToRobotDisplacementMag = cubeToRobotDisplacement.magnitude();\r\n            Vector2D cubeToRobotDisplacementOriented = new Vector2D(robotPosition.getDirection(), cubeToRobotDisplacementMag);\r\n            desiredPosition = robotPosition.add(cubeToRobotDisplacementOriented);\r\n\r\n            currentState = localizer.getCurrentState();\r\n            Vector2D positionError = desiredPosition.subtract(currentState.getPosition());\r\n            double errorAngle = positionError.getDirection();\r\n            //angleOfTravel += 0; // (Math.PI / 4.0)mecanum need this because all the math is shifted by pi/4\r\n            Vector2D idealVelocity = Vector2D.fromAngleMagnitude(errorAngle, desiredVelocity);\r\n\r\n            Vector2D recordedVelocity = currentState.getVelocity();\r\n            //recordedVelocity.rotate(-Math.PI / 4.0);\r\n\r\n            double xError = (idealVelocity.getX() - recordedVelocity.getX());\r\n            double yError = (idealVelocity.getY() - recordedVelocity.getY());\r\n            Vector2D error = new Vector2D(xError, yError);\r\n            //Vector2D crossTrackError = new Vector2D(xError, yError);\r\n            Vector2D deltaError = error.subtract(previousError);\r\n            error = error.multiply(pVelocity);\r\n            deltaError = deltaError.multiply(dVelocity);\r\n            error.add(deltaError);\r\n\r\n\r\n\r\n\r\n            //found and fixed stupid math error\r\n            Vector2D passedVector = previousVelocity.add(new Vector2D(error.getX(), error.getY()));\r\n            if(Math.abs(fl.getPower()) == 1.0 || Math.abs(fr.getPower()) == 1.0 || Math.abs(bl.getPower()) == 1.0 || Math.abs(br.getPower()) == 1.0){\r\n                passedVector = new Vector2D(previousVelocity.getX(), previousVelocity.getY());\r\n                desiredVelocity = passedVector.magnitude();\r\n            }\r\n//            Vector2D maxVector = new Vector2D(Math.cos(direction), Math.sin(direction));\r\n//            if(Math.abs(maxVector.getX()) < Math.abs(passedX)){\r\n//                if(getSign(maxVector.getX()) == getSign(passedX)){\r\n//                    passedX = maxVector.getX();\r\n//                }else{\r\n//                    passedX = -maxVector.getX();\r\n//                }\r\n//            }\r\n//            if(Math.abs(maxVector.getY()) < Math.abs(passedY)){\r\n//                if(getSign(maxVector.getY()) == getSign(passedY)){\r\n//                    passedY = maxVector.getY();\r\n//                }else{\r\n//                    passedY = -maxVector.getY();\r\n//                }\r\n//            }\r\n\r\n            //Vector2D passedVector = new Vector2D(passedX, passedY);\r\n            previousVelocity = setVelocity(passedVector,0);\r\n\r\n            // previousVelocity.multiply(sign);\r\n            previousError = error;\r\n\r\n\r\n            //AbstractOpMode.currentOpMode().telemetry.addData(\"\", currentState.toString());\r\n//\r\n            //AbstractOpMode.currentOpMode().telemetry.addData(\"distance\", Math.abs(newDesiredPosition.subtract(currentState.getPosition()).magnitude()));\r\n            //AbstractOpMode.currentOpMode().telemetry.addData(\"sign\", Math.abs(newDesiredPosition.subtract(currentState.getPosition()).magnitude()));\r\n\r\n            AbstractOpMode.currentOpMode().telemetry.addData(\"\", currentState);\r\n            //AbstractOpMode.currentOpMode().telemetry.addData(\"error\", (Math.abs(newDesiredPosition.subtract(currentState.getPosition()).magnitude())));\r\n\r\n            AbstractOpMode.currentOpMode().telemetry.update();\r\n        }\r\n    }\r\n\r\n    private final double pOmega = 0;\r\n    private void seekCubesRotate(double desiredOmega) {\r\n        double xPartitionDeviation = pipeline.xPointList().get(0);\r\n        previousOmega = 0;\r\n        environmentalTerminate = false;\r\n        while(xPartitionDeviation > 5 && AbstractOpMode.currentOpMode().opModeIsActive() && !eStop && !environmentalTerminate){\r\n            xPartitionDeviation = pipeline.xPointList().get(0);\r\n            double recordedOmega = localizer.getCurrentState().getAngularVelocity();\r\n            double omegaError = desiredOmega - recordedOmega;\r\n            omegaError *= pOmega;\r\n            double passedOmega = omegaError + previousOmega;\r\n            if(fl.getPower() == 1.0 || fr.getPower() == 1.0 || bl.getPower() == 1.0 || br.getPower() == 1.0){\r\n                passedOmega = 1.0;\r\n                desiredOmega = recordedOmega;\r\n            }else if(fl.getPower() == -1.0 || fr.getPower() == -1.0 || bl.getPower() == -1.0 || br.getPower() == -1.0){\r\n                passedOmega = -1.0;\r\n                desiredOmega = recordedOmega;\r\n            }\r\n            setVelocity(new Vector2D(0,0), passedOmega);\r\n            previousOmega = passedOmega;\r\n        }\r\n\r\n    }\r\n\r\n    public synchronized void strafeDistanceSensor(double omega, double radians){\r\n        strafeDistanceSensor(omega, radians, true);\r\n    }\r\n\r\n    public synchronized void strafeDistanceSensor(double omega, double radians, boolean isBrake){\r\n\r\n\r\n        environmentalTerminate = false;\r\n        double distanceFrontThreshold = 0.95;\r\n        double distanceBackThreshold = 0.95;\r\n        double lowMagnitudeFrontReading = 0;\r\n        double lowMagnitudeBackReading = 0;\r\n        //todo calibrate the tolerance of it.\r\n        AbstractOpMode.currentOpMode().telemetry.clear();\r\n        setEncoderMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n        setEncoderMode(DcMotor.RunMode.RUN_USING_ENCODER);\r\n\r\n        NormalizedRGBA frontRGBA;\r\n        NormalizedRGBA backRGBA;\r\n            if(isRed) {\r\n                frontRGBA = frontRed.getNormalizedColors();\r\n                backRGBA = backRed.getNormalizedColors();\r\n            }else{\r\n                frontRGBA = frontBlue.getNormalizedColors();\r\n                backRGBA = backBlue.getNormalizedColors();\r\n            }\r\n            while (frontRGBA.green < distanceFrontThreshold && backRGBA.green < distanceBackThreshold){\r\n\r\n                if(isRed) {\r\n                    frontRGBA = frontRed.getNormalizedColors();\r\n                    backRGBA = backRed.getNormalizedColors();\r\n                }else{\r\n                    frontRGBA = frontBlue.getNormalizedColors();\r\n                    backRGBA = backBlue.getNormalizedColors();\r\n                }\r\n                AbstractOpMode.currentOpMode().telemetry.addData(\"FGreen\", frontRGBA.green);\r\n                AbstractOpMode.currentOpMode().telemetry.addData(\"BGreen\", backRGBA.green);\r\n                AbstractOpMode.currentOpMode().telemetry.update();\r\n\r\n                double angle;\r\n                if(isRed){\r\n                    angle = 0;\r\n                }else{\r\n                    angle = Math.PI;\r\n                }\r\n\r\n                Vector2D vec = Vector2D.fromAngleMagnitude(radians + (Math.PI / 2.0) + angle, omega);\r\n                setVelocity(vec, 0);\r\n                Utils.sleep(100);\r\n\r\n            }\r\n        if(isBrake) {\r\n            brake();\r\n        }\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n    private void correctMotors() {\r\n        fl.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\r\n        fr.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\r\n        bl.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\r\n        br.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\r\n        fl.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\r\n        fr.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\r\n        bl.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\r\n        br.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\r\n        fl.setDirection(DcMotorSimple.Direction.REVERSE);\r\n        fr.setDirection(DcMotorSimple.Direction.REVERSE);\r\n        bl.setDirection(DcMotorSimple.Direction.REVERSE);\r\n        br.setDirection(DcMotorSimple.Direction.REVERSE);\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /**\r\n     * moving from position to position, assuming some kind of translational motion\r\n     * NEW no rotation involved since we can handle that as a single dimensional operation seperately rather than integrating it into the 3 dimensional operation it was\r\n     * @param desiredPosition the end point of the robot\r\n     * @param desiredVelocity the end velocity of the robot in inches per second\r\n     *\r\n     */\r\n\r\n    boolean maxReached;\r\n    Vector2D previousPosition;\r\n    int lowMagnitudeHardwareCycles;\r\n\r\n    public synchronized void moveToPosition(Vector2D desiredPosition, double desiredVelocity){\r\n\r\n        if(localizer == null){\r\n            return;\r\n        }\r\n        RobotPositionStateUpdater.RobotPositionState currentState = localizer.getCurrentState();\r\n        Vector2D desiredPositionPointer = new Vector2D(desiredPosition.getX() - currentState.getPosition().getX() , desiredPosition.getY() - currentState.getPosition().getY());\r\n        Vector2D newDesiredPosition = desiredPosition.add(new Vector2D(5.0 * Math.cos(desiredPositionPointer.getDirection()), 5.0 * Math.sin(desiredPositionPointer.getDirection())));\r\n        maxReached = false;\r\n        previousError = new Vector2D(0,0);\r\n        Vector2D steadyStateError = new Vector2D(0,0);\r\n        previousOmegaError = 0;\r\n        environmentalTerminate = false;\r\n        double heading = currentState.getRotation();\r\n        Debug.log(desiredVelocity);\r\n        lowMagnitudeHardwareCycles = 0;\r\n        previousPosition = currentState.getPosition();\r\n\r\n        while((Math.abs(newDesiredPosition.subtract(currentState.getPosition()).magnitude()) > 5.0) && AbstractOpMode.currentOpMode().opModeIsActive() && !eStop && !environmentalTerminate){\r\n\r\n            currentState = localizer.getCurrentState();\r\n            Vector2D position = currentState.getPosition();\r\n            Vector2D deltaPosition = position.subtract(previousPosition);\r\n            Vector2D positionError = desiredPosition.subtract(currentState.getPosition());\r\n            double errorAngle = positionError.getDirection() - heading;\r\n            //angleOfTravel += 0; // (Math.PI / 4.0)mecanum need this because all the math is shifted by pi/4\r\n            Vector2D idealVelocity = Vector2D.fromAngleMagnitude(errorAngle, desiredVelocity);\r\n\r\n            Vector2D recordedVelocity = currentState.getVelocity();\r\n            //recordedVelocity.rotate(-Math.PI / 4.0);\r\n\r\n            double xError = (idealVelocity.getX() - recordedVelocity.getX());\r\n            double yError = (idealVelocity.getY() - recordedVelocity.getY());\r\n            Vector2D error = new Vector2D(xError, yError);\r\n            //Vector2D crossTrackError = new Vector2D(xError, yError);\r\n            steadyStateError.add(error);\r\n            Vector2D deltaError = error.subtract(previousError);\r\n            error = error.multiply(pVelocity);\r\n            deltaError = deltaError.multiply(dVelocity);\r\n            error.add(deltaError);\r\n\r\n//            if(maxReached){\r\n//                error = new Vector2D(0,0);\r\n//            }\r\n\r\n\r\n\r\n            //found and fixed stupid math error\r\n            Vector2D passedVector = previousVelocity.add(new Vector2D(error.getX(), error.getY()));\r\n\r\n            if(passedVector.magnitude() > 1.0){\r\n                passedVector = passedVector.normalize();\r\n                desiredVelocity = recordedVelocity.magnitude();\r\n            }\r\n            previousVelocity = setPower(passedVector,0.0);\r\n\r\n           // previousVelocity.multiply(sign);\r\n            previousError = error;\r\n            previousPosition = new Vector2D(position.getX(), position.getY());\r\n\r\n\r\n//            AbstractOpMode.currentOpMode().telemetry.addData(\"\", currentState.toString());\r\n//            AbstractOpMode.currentOpMode().telemetry.addData(\"dpos\", deltaPosition.magnitude());\r\n//            AbstractOpMode.currentOpMode().telemetry.addData(\"\", lowMagnitudeHardwareCycles);\r\n\r\n\r\n            //AbstractOpMode.currentOpMode().telemetry.addData(\"distance\", Math.abs(newDesiredPosition.subtract(currentState.getPosition()).magnitude()));\r\n            //AbstractOpMode.currentOpMode().telemetry.addData(\"sign\", Math.abs(newDesiredPosition.subtract(currentState.getPosition()).magnitude()));\r\n//            AbstractOpMode.currentOpMode().telemetry.addData(\"\", currentState.toString());\r\n//            AbstractOpMode.currentOpMode().telemetry.addData(\"\", error);\r\n//            AbstractOpMode.currentOpMode().telemetry.addData(\"\", Math.abs(newDesiredPosition.subtract(currentState.getPosition()).magnitude()));\r\n\r\n\r\n\r\n\r\n            AbstractOpMode.currentOpMode().telemetry.update();\r\n\r\n\r\n        }\r\n        //AbstractOpMode.currentOpMode().telemetry.clear();\r\n        //Debug.log(\"done\");\r\n        brake();\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n    public String getMotorPower(){\r\n        return\"fl: \" + fl.getPower() + \"\\n\" +\r\n                \"fr: \" + fr.getPower() + \"\\n\" +\r\n                \"bl: \" + bl.getPower() + \"\\n\" +\r\n                \"br: \" + br.getPower();\r\n    }\r\n\r\n    public Vector2D setVelocity(Vector2D velocity, double turnValue){\r\n        turnValue = -turnValue;\r\n        double direction = velocity.getDirection();\r\n\r\n\r\n\r\n        double power = velocity.magnitude();\r\n\r\n        double angle = direction + (Math.PI / 4.0);\r\n        double sin = Math.sin(angle);\r\n        double cos = Math.cos(angle);\r\n\r\n        setMotorVelocity((power * sin - turnValue),(power * cos - turnValue),\r\n                (power * cos + turnValue), (power * sin + turnValue));\r\n        return new Vector2D(velocity.getX(), velocity.getY());\r\n    }\r\n        //Vt = rw\r\n    private final double WHEEL_RADIUS_IN = 1.88976; // radius of the 96mm gobilda wheels in IN\r\n    public void setMotorVelocity(double flVelocity, double frVelocity, double blVelocity, double brVelocity){\r\n\r\n        fl.setVelocity(-flVelocity * WHEEL_RADIUS_IN, AngleUnit.RADIANS);\r\n        fr.setVelocity(frVelocity * WHEEL_RADIUS_IN, AngleUnit.RADIANS);\r\n        bl.setVelocity(-blVelocity * WHEEL_RADIUS_IN, AngleUnit.RADIANS);\r\n        br.setVelocity(brVelocity * WHEEL_RADIUS_IN, AngleUnit.RADIANS);\r\n    }\r\n\r\n\r\n    double previousOmega;\r\n    double pRotation;\r\n    public synchronized void moveToRotation(double desiredRotation, double omega){\r\n        if(localizer == null){\r\n            return;\r\n        }\r\n        RobotPositionStateUpdater.RobotPositionState state = localizer.getCurrentState();\r\n        previousOmega = 0;\r\n        environmentalTerminate = false;\r\n        while(Math.abs(desiredRotation - state.getRotation()) > 0.05 && AbstractOpMode.currentOpMode().opModeIsActive() && !eStop && !environmentalTerminate){\r\n            state = localizer.getCurrentState();\r\n            double recordedOmega = state.getAngularVelocity();\r\n            double omegaError = omega - recordedOmega;\r\n            omegaError *= pRotation;\r\n            omega += omegaError;\r\n            setVelocity(new Vector2D(0,0), omega);\r\n//            AbstractOpMode.currentOpMode().telemetry.addData(\"\", state.toString());\r\n//            AbstractOpMode.currentOpMode().telemetry.update();\r\n        }\r\n        brake();\r\n    }\r\n\r\n    public synchronized void rotateDistance(double radians, double power){\r\n        RobotPositionStateUpdater.RobotPositionState state = localizer.getCurrentState();\r\n\r\n        environmentalTerminate = false;\r\n\r\n        while(Math.abs((state.getRotation() - radians))  > 0.05 && AbstractOpMode.currentOpMode().opModeIsActive() && !environmentalTerminate && !eStop){\r\n            state = localizer.getCurrentState();\r\n//            AbstractOpMode.currentOpMode().telemetry.addData(\"\", state);\r\n//            AbstractOpMode.currentOpMode().telemetry.update();\r\n            setPower(power, -power, power, -power);\r\n        }\r\n        brake();\r\n\r\n\r\n    }\r\n\r\n    public void brake() {\r\n        fl.setPower(0);\r\n        fr.setPower(0);\r\n        bl.setPower(0);\r\n        br.setPower(0);\r\n        previousVelocity = new Vector2D(0,0);\r\n    }\r\n\r\n\r\n    public DcMotor[] getMotors(){\r\n        return new DcMotor[]{fl,fr,bl,br};\r\n    }\r\n\r\n\r\n    /*\r\n    gets the robot driving in a specified direction\r\n     */\r\n    public Vector2D setPower(Vector2D velocity, double turnValue){\r\n        turnValue = -turnValue;\r\n        double direction = velocity.getDirection();\r\n\r\n\r\n\r\n        double power = velocity.magnitude();\r\n\r\n        double angle = direction + ( Math.PI / 4.0);\r\n        double sin = Math.sin(angle);\r\n        double cos = Math.cos(angle);\r\n\r\n        setPower((power * sin - turnValue),(power * cos + turnValue),\r\n                (power * cos - turnValue), (power * sin + turnValue));\r\n        return new Vector2D(velocity.getX(), velocity.getY());\r\n    }\r\n\r\n    public Vector2D setPower(Vector2D velocity, double turnValue, double robotHeading){\r\n        turnValue = -turnValue;\r\n        double direction = velocity.getDirection() + robotHeading;\r\n\r\n\r\n\r\n        double power = velocity.magnitude();\r\n\r\n        double angle = direction + ( Math.PI / 4.0);\r\n        double sin = Math.sin(angle);\r\n        double cos = Math.cos(angle);\r\n\r\n        setPower((power * sin - turnValue),(power * cos + turnValue),\r\n                (power * cos - turnValue), (power * sin + turnValue));\r\n        return new Vector2D(velocity.getX(), velocity.getY());\r\n    }\r\n\r\n\r\n    public void setPower(double flPow, double frPow, double blPow, double brPow) {\r\n        fl.setPower(-flPow);\r\n        fr.setPower(frPow);\r\n        bl.setPower(-blPow);\r\n        br.setPower(brPow);\r\n    }\r\n\r\n    public double setStrafe(double val){\r\n        if(!isRed){\r\n            setPower(-val, val, val, -val);\r\n        }else {\r\n            setPower(val, -val, -val, val);\r\n        }\r\n        return val;\r\n    }\r\n\r\n    private boolean isNear(double globalRads, double angle, boolean isBig) {\r\n        if (isBig) {\r\n            return Math.abs(globalRads - angle) < (2 * ANGULAR_TOLERANCE);\r\n        }else {\r\n            return Math.abs(globalRads - angle) < (ANGULAR_TOLERANCE);\r\n        }\r\n    }\r\n\r\n    public void zero() {\r\n        setPower(0,0,0,0);\r\n    }\r\n\r\n    private int getSign(double num){\r\n        if(num < 0){\r\n            return -1;\r\n        }else {\r\n            return 1;\r\n        }\r\n    }\r\n\r\n    private static final double WHEELBASE_X = 10.5;\r\n    private static final double WHEELBASE_Y = 13.25;\r\n\r\n    /**\r\n     * arcs in auto\r\n     * @param motion the angle of the chord and the magnitude of the velocity\r\n     * @param omega rotational velocity to be applied, should be at a 1:1 with velocity magnitude for\r\n     *              circular arcs\r\n     * @param arclength median arclength between the wheelbases\r\n     * @param dAngle angle of the arc in degrees\r\n     */\r\n\r\n    public void arcDriving(Vector2D motion, double omega, int arclength, double dAngle){\r\n        dAngle = Math.toRadians(dAngle);\r\n        double[][] inverseKinematicModelArr = new double[][]{\r\n                {1,-1, -(WHEELBASE_X + WHEELBASE_Y)},\r\n                {1,1, (WHEELBASE_X + WHEELBASE_Y)},\r\n                {1,1, -(WHEELBASE_X + WHEELBASE_Y)},\r\n                {1,-1, (WHEELBASE_X + WHEELBASE_Y)}};\r\n        double[][] motionModelArr = new double[][]{{motion.getX()}, {motion.getY()}, {omega}};\r\n\r\n        Matrix inverseKinematicModel = new Matrix(inverseKinematicModelArr);\r\n        Matrix motionModel = new Matrix(motionModelArr);\r\n\r\n        Matrix wheelMotions = inverseKinematicModel.multiply(motionModel);\r\n\r\n        wheelMotions.multiply(1.0 / WHEEL_RADIUS_IN);\r\n\r\n        setEncoderMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n        setEncoderMode(DcMotor.RunMode.RUN_USING_ENCODER);\r\n\r\n        double minArcLength = arclength - (WHEELBASE_X / 2.0) * dAngle;\r\n        double maxArcLength = arclength + (WHEELBASE_X / 2.0) * dAngle;\r\n\r\n        hub.clearBulkCache();\r\n        LynxModule.BulkData data = hub.getBulkData();\r\n\r\n        while(data.getMotorCurrentPosition(0) < minArcLength || data.getMotorCurrentPosition(1) < maxArcLength ||\r\n                data.getMotorCurrentPosition(2) < minArcLength || data.getMotorCurrentPosition(3) < maxArcLength) {\r\n            hub.clearBulkCache();\r\n            data = hub.getBulkData();\r\n            setMotorVelocity(wheelMotions.getValue(0, 0), wheelMotions.getValue(1, 0),\r\n                    wheelMotions.getValue(2, 0), wheelMotions.getValue(3, 0));\r\n        }\r\n        brake();\r\n    }\r\n\r\n\r\n    /**\r\n     * types of movement I need to splice\r\n     * linear\r\n     * rotation\r\n     * color sensor localization\r\n     * warehouse color sensor movement.\r\n     * @param movements\r\n     */\r\n    public synchronized void splicedMovement(ArrayList<Movement> movements){\r\n        hub.clearBulkCache();\r\n        LynxModule.BulkData data = hub.getBulkData();\r\n        setEncoderMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n        setEncoderMode(DcMotor.RunMode.RUN_USING_ENCODER);\r\n        for(int i = 0; i < movements.size(); i++){\r\n            Movement curr = movements.get(i);\r\n            if(curr.getMovement() == Movement.MovementType.TRANSLATION) {\r\n                double distance = curr.getDistance();\r\n                double radians = curr.getRadians();\r\n                int flDistance = (int) (Math.sin(radians) * distance);\r\n                int frDistance = (int) (Math.cos(radians) * distance);\r\n                int blDistance = (int) (Math.cos(radians) * distance);\r\n                int brDistance = (int) (Math.sin(radians) * distance);\r\n\r\n                hub.clearBulkCache();\r\n                data = hub.getBulkData();\r\n                int flInit = data.getMotorCurrentPosition(0);\r\n                int frInit = data.getMotorCurrentPosition(1);\r\n                int blInit = data.getMotorCurrentPosition(2);\r\n                int brInit = data.getMotorCurrentPosition(3);\r\n                Vector2D vec = Vector2D.fromAngleMagnitude(radians, curr.getVelocity());\r\n\r\n                while (Math.abs(data.getMotorCurrentPosition(0) - flInit) < flDistance ||\r\n                        Math.abs(data.getMotorCurrentPosition(1) - frInit) < frDistance ||\r\n                        Math.abs(data.getMotorCurrentPosition(2) - blInit) < blDistance ||\r\n                        Math.abs(data.getMotorCurrentPosition(3) - brInit) < brDistance){\r\n\r\n                    hub.clearBulkCache();\r\n                    data = hub.getBulkData();\r\n\r\n                    setVelocity(vec, 0);\r\n                }\r\n            }else if(curr.getMovement() == Movement.MovementType.ROTATION){\r\n                double omega = curr.getOmega();\r\n                double deltaRadians = curr.getRotation() - imu.getAngularOrientation().firstAngle;\r\n                double startAngle = imu.getAngularOrientation().firstAngle;\r\n                omega *= -getSign(deltaRadians);\r\n                while(Math.abs(startAngle - imu.getAngularOrientation().firstAngle) < Math.abs(deltaRadians)){\r\n                    setMotorVelocity(omega, -omega, omega, -omega);\r\n                }\r\n            }else if(curr.getMovement() == Movement.MovementType.PAUSE){\r\n                brake();\r\n                Utils.sleep(curr.getMillis());\r\n            }else if(curr.getMovement() == Movement.MovementType.WALL_LOCALIZATION){\r\n                strafeDistanceSensor(curr.getVelocity(), curr.getRadians(), true);\r\n            }else if(curr.getMovement() == Movement.MovementType.WAREHOUSE_LOCALIZATION){\r\n                driveColorSensorWarehouse(curr.getVelocity());\r\n            }else if(curr.getMovement() == Movement.MovementType.MODIFY_FLAG){\r\n                flags[curr.getIndex()] = curr.getVal();\r\n            }else if(curr.getMovement() == Movement.MovementType.WAREHOUSE_OPERATION){\r\n                driveColorSensorSpliced(curr.getVelocity());\r\n            }\r\n        }\r\n        brake();\r\n    }\r\n\r\n    public synchronized boolean getFlagIndex(int index){\r\n        return flags[index];\r\n    }\r\n\r\n    public synchronized void setFlagIndex(int index, boolean val){\r\n        flags[index] = val;\r\n    }\r\n\r\n    public void setEnvironmentalTerminate(boolean val){\r\n        environmentalTerminate = val;\r\n    }\r\n\r\n    public void seteStop(boolean val){\r\n        eStop = val;\r\n    }\r\n\r\n    public NormalizedRGBA getSensorRGBA(){\r\n        return sensor.getNormalizedColors();\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/TeamCode/src/main/java/teamcode/common/MecanumDriveTrain.java b/TeamCode/src/main/java/teamcode/common/MecanumDriveTrain.java
--- a/TeamCode/src/main/java/teamcode/common/MecanumDriveTrain.java	(revision 183b0a7a895e8187661be6ba39779130728cc9b2)
+++ b/TeamCode/src/main/java/teamcode/common/MecanumDriveTrain.java	(date 1646712638990)
@@ -53,7 +53,7 @@
     private boolean isRed;
     private volatile boolean[] flags;
 
-
+    private boolean duckDetected;
     /**
      * PID Constants
      *
@@ -318,15 +318,15 @@
                 Math.abs(data.getMotorCurrentPosition(2)) < Math.abs(blDistance) || Math.abs(data.getMotorCurrentPosition(3)) < Math.abs(brDistance)){
             hub.clearBulkCache();
             data = hub.getBulkData();
-            AbstractOpMode.currentOpMode().telemetry.addData("fl",data.getMotorCurrentPosition(0));
-            AbstractOpMode.currentOpMode().telemetry.addData("fl", flDistance);
-            AbstractOpMode.currentOpMode().telemetry.addData("fr", data.getMotorCurrentPosition(1));
-            AbstractOpMode.currentOpMode().telemetry.addData("fr", frDistance);
-            AbstractOpMode.currentOpMode().telemetry.addData("bl", data.getMotorCurrentPosition(2));
-            AbstractOpMode.currentOpMode().telemetry.addData("bl", blDistance);
-            AbstractOpMode.currentOpMode().telemetry.addData("br", data.getMotorCurrentPosition(3));
-            AbstractOpMode.currentOpMode().telemetry.addData("br", brDistance);
-            AbstractOpMode.currentOpMode().telemetry.update();
+//            AbstractOpMode.currentOpMode().telemetry.addData("fl",data.getMotorCurrentPosition(0));
+//            AbstractOpMode.currentOpMode().telemetry.addData("fl", flDistance);
+//            AbstractOpMode.currentOpMode().telemetry.addData("fr", data.getMotorCurrentPosition(1));
+//            AbstractOpMode.currentOpMode().telemetry.addData("fr", frDistance);
+//            AbstractOpMode.currentOpMode().telemetry.addData("bl", data.getMotorCurrentPosition(2));
+//            AbstractOpMode.currentOpMode().telemetry.addData("bl", blDistance);
+//            AbstractOpMode.currentOpMode().telemetry.addData("br", data.getMotorCurrentPosition(3));
+//            AbstractOpMode.currentOpMode().telemetry.addData("br", brDistance);
+//            AbstractOpMode.currentOpMode().telemetry.update();
 
             setVelocity(vec, 0);
         }
@@ -474,40 +474,49 @@
         arm.intakeDumb(0);
     }
 
-    public void semiDumbVisionDriving(double pow){
-        while(!somethingInThePartition()){ //add the  conditional with something in the partition
-            setStrafe(pow);
+
+
+//    public void semiDumbVisionDriving(double pow){
+//        while(!somethingInThePartition()){ //add the  conditional with something in the partition
+//            setStrafe(pow);
+//        }
+//        setEncoderMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
+//        setEncoderMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);
+//        boolean detectedElement = false;
+//        while(!detectedElement){
+//            arm.lowerLinkage();
+//            arm.intakeDumb(1.0);
+//            NormalizedRGBA colors = sensor.getNormalizedColors();
+//            double green = colors.green;
+//            if (green > 0.9) {
+//                detectedElement = true;
+//            } else {
+//                detectedElement = false;
+//            }
+//            setPower(pow, pow, pow, pow);
+//        }
+//        hub.clearBulkCache();
+//        LynxModule.BulkData data = hub.getBulkData();
+//        int posAvg = 0;
+//        for(int i = 0; i < 4; i++){
+//            int pos = data.getMotorCurrentPosition(i);
+//            posAvg += pos;
+//        }
+//        posAvg = posAvg / 4;
+//        moveDistanceDEVelocity(-posAvg, 0, 6);
+//        strafeDistanceSensor(0.3, 0);
+//    }
+
+    public void strafeDuck(double direction) {
+        while (!duckDetected) {
+//            setStrafe(direction);
         }
-        setEncoderMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
-        setEncoderMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);
-        boolean detectedElement = false;
-        while(!detectedElement){
-            arm.lowerLinkage();
-            arm.intakeDumb(1.0);
-            NormalizedRGBA colors = sensor.getNormalizedColors();
-            double green = colors.green;
-            if (green > 0.9) {
-                detectedElement = true;
-            } else {
-                detectedElement = false;
-            }
-            setPower(pow, pow, pow, pow);
-        }
-        hub.clearBulkCache();
-        LynxModule.BulkData data = hub.getBulkData();
-        int posAvg = 0;
-        for(int i = 0; i < 4; i++){
-            int pos = data.getMotorCurrentPosition(i);
-            posAvg += pos;
-        }
-        posAvg = posAvg / 4;
-        moveDistanceDEVelocity(-posAvg, 0, 6);
-        strafeDistanceSensor(0.3, 0);
     }
-    private boolean somethingInThePartition(){
-        //replace this with something that actually works Mason
-        return true;
+
+    public void setDuckDetected(boolean detected) {
+        duckDetected = detected;
     }
+
     public void SmartVisionDriving(double pow, Object pipeline){
         double theta = 0;
         pipeline.getClass(); //getThetaValue()
